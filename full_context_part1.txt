
============================================================
FILE: build.gradle.kts
============================================================

// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
}

============================================================
FILE: settings.gradle.kts
============================================================

pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
        // Try the standard jitpack again with a fresh proxy setting
        maven { url = uri("https://jitpack.io") }
    }
}

rootProject.name = "Hotspot-Bypass-VPN"
include(":app")

============================================================
FILE: app\build.gradle.kts
============================================================

plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
}

android {
    namespace = "com.example.hotspot_bypass_vpn"
    compileSdk = 35

    defaultConfig {
        applicationId = "com.example.hotspot_bypass_vpn"
        minSdk = 24
        targetSdk = 35
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"

        ndk {
            abiFilters.addAll(listOf("armeabi-v7a", "arm64-v8a", "x86", "x86_64"))
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }
    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }
    kotlinOptions {
        jvmTarget = "11"
    }
}

dependencies {
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.appcompat)
    implementation(libs.material)
    implementation(libs.androidx.activity)
    implementation(libs.androidx.constraintlayout)
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)

    // Alternative: Use OkHttp for SOCKS proxy support
    implementation("com.squareup.okhttp3:okhttp:4.12.0")
}

============================================================
FILE: app\src\main\AndroidManifest.xml
============================================================

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.CHANGE_NETWORK_STATE" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
    <uses-permission android:name="android.permission.NEARBY_WIFI_DEVICES"
        android:usesPermissionFlags="neverForLocation" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />

    <!-- Foreground Service Permissions -->
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_SPECIAL_USE" /> <!-- ADD THIS -->
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" /> <!-- Recommended for SDK 33+ -->

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.HotspotBypassVPN">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />

                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <service
            android:name=".MyVpnService"
            android:permission="android.permission.BIND_VPN_SERVICE"
            android:foregroundServiceType="specialUse"
            android:exported="false">
            <intent-filter>
                <action android:name="android.net.VpnService" />
            </intent-filter>
            <property
                android:name="android.app.PROPERTY_SPECIAL_USE_FGS_SUBTYPE"
                android:value="VPN proxy for hotspot bypass" />
        </service>
    </application>

</manifest>

============================================================
FILE: app\src\main\java\com\example\hotspot_bypass_vpn\DebugUtils.kt
============================================================

package com.example.hotspot_bypass_vpn

import android.util.Log
import java.net.InetAddress
import java.net.InetSocketAddress
import java.net.Socket
import java.util.concurrent.atomic.AtomicInteger

object DebugUtils {
    private const val TAG = "VPN_DEBUG"
    private val connectionCounter = AtomicInteger(0)

    fun log(message: String) {
        Log.d(TAG, "[${Thread.currentThread().name}] $message")
    }

    fun error(message: String, e: Throwable? = null) {
        Log.e(TAG, "[${Thread.currentThread().name}] $message", e)
    }

    fun testProxyConnection(proxyIp: String, proxyPort: Int): Boolean {
        return try {
            log("Testing connection to proxy: $proxyIp:$proxyPort")
            val socket = Socket()
            socket.connect(InetSocketAddress(proxyIp, proxyPort), 5000)
            socket.close()
            log("✓ Proxy connection test PASSED")
            true
        } catch (e: Exception) {
            error("✗ Proxy connection test FAILED: ${e.message}")
            false
        }
    }

    fun testInternetConnectivity(): Boolean {
        return try {
            log("Testing internet connectivity")
            val socket = Socket()
            socket.connect(InetSocketAddress("8.8.8.8", 53), 3000)
            socket.close()
            log("✓ Internet connectivity test PASSED")
            true
        } catch (e: Exception) {
            error("✗ Internet connectivity test FAILED: ${e.message}")
            false
        }
    }

    fun dumpVpnStats(
        tcpConnections: Map<*, *>,
        udpSockets: Map<*, *>,
        writeQueueSize: Int,
        poolActiveCount: Int,
        poolQueueSize: Int
    ) {
        log("VPN Stats:")
        log("  TCP Connections: ${tcpConnections.size}")
        log("  UDP Sockets: ${udpSockets.size}")
        log("  Write Queue: $writeQueueSize")
        log("  Pool Active: $poolActiveCount")
        log("  Pool Queue: $poolQueueSize")
    }
}

============================================================
FILE: app\src\main\java\com\example\hotspot_bypass_vpn\MainActivity.kt
============================================================

package com.example.hotspot_bypass_vpn

import android.Manifest
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.PackageManager
import android.net.VpnService
import android.net.wifi.p2p.WifiP2pGroup
import android.net.wifi.p2p.WifiP2pInfo
import android.net.wifi.p2p.WifiP2pManager
import android.os.Build
import android.os.Bundle
import android.widget.Button
import android.widget.EditText
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import kotlin.concurrent.thread
import android.provider.Settings
import androidx.core.content.ContextCompat

class MainActivity : AppCompatActivity(), WifiP2pManager.ConnectionInfoListener {

    private val proxyServer = ProxyServer()

    // Wifi P2P Variables
    private lateinit var manager: WifiP2pManager
    private lateinit var channel: WifiP2pManager.Channel
    private lateinit var receiver: BroadcastReceiver
    private val intentFilter = IntentFilter()

    // UI Elements
    private lateinit var tvHostInfo: TextView
    private lateinit var tvStatusLog: TextView
    private lateinit var etIp: EditText
    private lateinit var etPort: EditText

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        val btnDebug = findViewById<Button>(R.id.btn_debug)

        // 1. Initialize UI Elements
        val btnStartHost = findViewById<Button>(R.id.btn_start_host)
        val btnConnect = findViewById<Button>(R.id.btn_connect)
        tvHostInfo = findViewById(R.id.tv_host_info)
        tvStatusLog = findViewById(R.id.tv_status_log)
        etIp = findViewById(R.id.et_host_ip)
        etPort = findViewById(R.id.et_host_port)

        // 2. Initialize Wi-Fi Direct
        manager = getSystemService(Context.WIFI_P2P_SERVICE) as WifiP2pManager
        channel = manager.initialize(this, mainLooper, null)

        intentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION)
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION)

        checkPermissions()

        // 3. Logic for MODE A: HOST (Sharing)
        btnStartHost.setOnClickListener {
            startHost()
        }

        // Add this listener
        btnDebug.setOnClickListener {
            runInternetPingTest()
        }

        // 4. Logic for MODE B: CLIENT (Connecting)
        btnConnect.setOnClickListener {
            val ip = etIp.text.toString()
            val portStr = etPort.text.toString()

            if (ip.isEmpty() || portStr.isEmpty()) {
                Toast.makeText(this, "Please enter IP and Port", Toast.LENGTH_SHORT).show()
                return@setOnClickListener
            }

            val port = portStr.toIntOrNull() ?: 8080

            // Test connectivity first
            testConnectivity(ip, port)

            // Then start VPN
            prepareVpn(ip, port)
        }
    }

    // --- VPN CLIENT LOGIC ---

    private fun prepareVpn(ip: String, port: Int) {
        val intent = VpnService.prepare(this)
        if (intent != null) {
            // Asks user: "Do you trust this app to start a VPN?"
            startActivityForResult(intent, 102)
        } else {
            // Already have permission
            startVpnService(ip, port)
        }
    }

    private fun startVpnService(ip: String, port: Int) {
        val intent = Intent(this, MyVpnService::class.java).apply {
            putExtra("PROXY_IP", ip)
            putExtra("PROXY_PORT", port)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            startForegroundService(intent)
        } else {
            startService(intent)
        }
        log("VPN Client Starting... Connecting to $ip:$port")
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (requestCode == 102 && resultCode == RESULT_OK) {
            val ip = etIp.text.toString()
            val port = etPort.text.toString().toInt()
            startVpnService(ip, port)
        }
    }

    // --- WIFI DIRECT HOST LOGIC ---

    private fun startHost() {
        manager.removeGroup(channel, object : WifiP2pManager.ActionListener {
            override fun onSuccess() { createNewGroup() }
            override fun onFailure(reason: Int) { createNewGroup() }
        })
    }

    private fun createNewGroup() {
        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
            log("Permission Error")
            return
        }
        manager.createGroup(channel, object : WifiP2pManager.ActionListener {
            override fun onSuccess() { log("Creating Group...") }
            override fun onFailure(reason: Int) { log("Error: $reason") }
        })
    }

    override fun onConnectionInfoAvailable(info: WifiP2pInfo?) {
        if (info != null && info.groupFormed) {
            val hostIp = info.groupOwnerAddress?.hostAddress ?: "192.168.49.1"
            log("NETWORK ACTIVE. Host IP: $hostIp")
            // Use this IP in Phone B
        }
    }

    fun updateGroupInfo(group: WifiP2pGroup?) {
        if (group != null && group.isGroupOwner) {
            proxyServer.start() // Start the SOCKS5 server on Phone A
            tvHostInfo.text = "SSID: ${group.networkName}\nPASS: ${group.passphrase}\nIP: 192.168.49.1\nPORT: 8080"
            log("Proxy Running.")
        }
    }

    // --- LIFECYCLE ---

    private val logReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            val message = intent?.getStringExtra("message") ?: ""
            log(message)
        }
    }

    override fun onResume() {
        super.onResume()
        receiver = WiFiDirectBroadcastReceiver(manager, channel, this)
        registerReceiver(receiver, intentFilter)

        // FIX: Use ContextCompat to support API 24 while using modern security flags
        ContextCompat.registerReceiver(
            this,
            logReceiver,
            IntentFilter("VPN_LOG"),
            ContextCompat.RECEIVER_NOT_EXPORTED
        )
    }

    override fun onPause() {
        super.onPause()
        try {
            unregisterReceiver(receiver)
        } catch (e: IllegalArgumentException) {
            // Receiver was not registered
        }

        try {
            unregisterReceiver(logReceiver)
        } catch (e: IllegalArgumentException) {
            // Receiver was not registered
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        proxyServer.stop()
        manager.removeGroup(channel, null)
    }

    private fun checkPermissions() {
        val permissions = mutableListOf(
            Manifest.permission.ACCESS_FINE_LOCATION,
            Manifest.permission.CHANGE_WIFI_STATE,
            Manifest.permission.ACCESS_WIFI_STATE
        )
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            permissions.add(Manifest.permission.NEARBY_WIFI_DEVICES)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            permissions.add(Manifest.permission.POST_NOTIFICATIONS)
        }
        ActivityCompat.requestPermissions(this, permissions.toTypedArray(), 101)
    }

    private fun log(message: String) {
        runOnUiThread {
            val currentText = tvStatusLog.text.toString()
            tvStatusLog.text = "$message\n$currentText"
        }
    }

    private fun testConnectivity(ip: String, port: Int) {
        thread {
            try {
                DebugUtils.log("Starting connectivity test...")

                // Test 1: Basic socket connection
                val canConnect = DebugUtils.testProxyConnection(ip, port)

                runOnUiThread {
                    if (canConnect) {
                        Toast.makeText(this, "✓ Can connect to proxy", Toast.LENGTH_SHORT).show()
                        log("Connectivity test PASSED")
                    } else {
                        Toast.makeText(this, "✗ Cannot connect to proxy", Toast.LENGTH_SHORT).show()
                        log("Connectivity test FAILED")
                    }
                }

                // Test 2: Test internet via proxy (optional)
                if (canConnect) {
                    testInternetViaProxy(ip, port)
                }

            } catch (e: Exception) {
                runOnUiThread {
                    log("Test error: ${e.message}")
                }
            }
        }
    }

    private fun testInternetViaProxy(ip: String, port: Int) {
        thread {
            try {
                DebugUtils.log("Testing internet via proxy...")

                // This is a simple test - you'd need to implement proper SOCKS5 client
                // For now, just log that we're trying
                log("Attempting to route traffic through proxy $ip:$port")

            } catch (e: Exception) {
                log("Proxy routing test error: ${e.message}")
            }
        }
    }

    private fun checkVpnPermission(): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            if (Settings.canDrawOverlays(this)) {
                true
            } else {
                val intent = Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION)
                startActivity(intent)
                false
            }
        } else {
            true
        }
    }

    private fun runInternetPingTest() {
        log("--- Starting Connectivity Test ---")

        thread {
            // Test 1: TCP "Ping" to Google DNS (8.8.8.8)
            // We use a Socket instead of ICMP Ping because SOCKS5 proxies
            // usually don't support ICMP.
            try {
                val host = "8.8.8.8"
                val port = 53
                val timeout = 5000
                val startTime = System.currentTimeMillis()

                val socket = java.net.Socket()
                socket.connect(java.net.InetSocketAddress(host, port), timeout)
                val endTime = System.currentTimeMillis()
                socket.close()

                log("✓ Internet Reachable: Connected to $host in ${endTime - startTime}ms")
            } catch (e: Exception) {
                log("✗ Internet Unreachable: ${e.message}")
            }

            // Test 2: DNS Resolution
            // This tests if your handleDnsOverTcp function in MyVpnService is working
            try {
                log("Testing DNS resolution (google.com)...")
                val dnsStart = System.currentTimeMillis()
                val address = java.net.InetAddress.getByName("google.com")
                val dnsEnd = System.currentTimeMillis()

                log("✓ DNS Success: google.com -> ${address.hostAddress} (${dnsEnd - dnsStart}ms)")
            } catch (e: Exception) {
                log("✗ DNS Failed: ${e.message}")
                log("Tip: Check if Phone A has Mobile Data enabled.")
            }
        }
    }
}

============================================================
FILE: app\src\main\java\com\example\hotspot_bypass_vpn\MyVpnService.kt
============================================================

package com.example.hotspot_bypass_vpn

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Intent
import android.net.VpnService
import android.os.Build
import android.os.ParcelFileDescriptor
import android.util.Log
import androidx.core.app.NotificationCompat
import java.io.FileInputStream
import java.io.FileOutputStream
import java.net.DatagramPacket
import java.net.DatagramSocket
import java.net.InetSocketAddress
import java.net.InetAddress
import java.net.Socket
import java.nio.ByteBuffer
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.LinkedBlockingQueue
import java.util.concurrent.ThreadPoolExecutor
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.concurrent.thread

class MyVpnService : VpnService() {

    private var vpnInterface: ParcelFileDescriptor? = null
    private var isRunning = false
    private var proxyIp = ""
    private var proxyPort = 0

    private val tcpConnections = ConcurrentHashMap<String, TcpConnection>()
    private val udpSockets = ConcurrentHashMap<String, UdpRelay>()

    private val connectionPool = ThreadPoolExecutor(
        15, 250, 60L, TimeUnit.SECONDS,
        LinkedBlockingQueue(1000), ThreadPoolExecutor.CallerRunsPolicy()
    )

    private val vpnWriteQueue = LinkedBlockingQueue<ByteArray>(2000)
    private var vpnWriter: FileOutputStream? = null

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        proxyIp = intent?.getStringExtra("PROXY_IP") ?: "192.168.49.1"
        proxyPort = intent?.getIntExtra("PROXY_PORT", 8080) ?: 8080

        startForegroundNotification()

        thread(name = "ProxyTest") {
            if (DebugUtils.testProxyConnection(proxyIp, proxyPort)) {
                startVpnInterface()
            } else {
                updateNotification("Error: Cannot reach Phone A")
                stopSelf()
            }
        }
        return START_STICKY
    }

    private fun startVpnInterface() {
        val builder = Builder()
            .setMtu(1500) // Increased to Standard MTU for speed
            .addAddress("10.0.0.2", 32)
            .addRoute("0.0.0.0", 0)
            .addDisallowedApplication(packageName)
            .addDnsServer("8.8.8.8")
            .setBlocking(false)

        vpnInterface = builder.establish()

        if (vpnInterface != null) {
            isRunning = true
            updateNotification("VPN Active - High Performance Mode")
            thread(name = "VPN-Writer", isDaemon = true) { runVpnWriter() }
            thread(name = "VPN-Reader", isDaemon = true) { readPackets() }
            thread(name = "Cleanup", isDaemon = true) { cleanupStaleConnections() }
        }
    }

    private fun runVpnWriter() {
        vpnWriter = FileOutputStream(vpnInterface!!.fileDescriptor)
        try {
            while (isRunning) {
                val packet = vpnWriteQueue.poll(100, TimeUnit.MILLISECONDS)
                if (packet != null) vpnWriter?.write(packet)
            }
        } catch (e: Exception) { }
    }

    private fun writeToVpn(packet: ByteArray) {
        vpnWriteQueue.offer(packet)
    }

    private fun readPackets() {
        val inputStream = FileInputStream(vpnInterface!!.fileDescriptor)
        val buffer = ByteBuffer.allocate(16384) // Larger read buffer
        try {
            while (isRunning) {
                val length = inputStream.read(buffer.array())
                if (length > 0) {
                    val packet = ByteBuffer.wrap(buffer.array().copyOf(length))
                    handlePacket(packet)
                    buffer.clear()
                }
            }
        } catch (e: Exception) { }
    }

    private fun handlePacket(packet: ByteBuffer) {
        if (packet.limit() < 20) return
        val version = (packet.get(0).toInt() shr 4) and 0x0F
        if (version != 4) return
        val protocol = packet.get(9).toInt() and 0xFF

        when (protocol) {
            6 -> handleTcpPacket(packet)
            17 -> handleUdpPacket(packet)
        }
    }

    private fun handleUdpPacket(packet: ByteBuffer) {
        try {
            val ipHeaderLen = (packet.get(0).toInt() and 0x0F) * 4
            val ipTotalLen = ((packet.get(2).toInt() and 0xFF) shl 8) or (packet.get(3).toInt() and 0xFF)
            if (packet.limit() < ipHeaderLen + 8) return

            val srcIp = parseIpAddress(packet, 12)
            val destIp = parseIpAddress(packet, 16)
            val srcPort = ((packet.get(ipHeaderLen).toInt() and 0xFF) shl 8) or (packet.get(ipHeaderLen + 1).toInt() and 0xFF)
            val destPort = ((packet.get(ipHeaderLen + 2).toInt() and 0xFF) shl 8) or (packet.get(ipHeaderLen + 3).toInt() and 0xFF)

            val payloadStart = ipHeaderLen + 8
            val payloadSize = ipTotalLen - ipHeaderLen - 8
            if (payloadSize <= 0) return

            val payload = ByteArray(payloadSize)
            packet.position(payloadStart)
            packet.get(payload)

            if (destPort == 53) {
                connectionPool.execute { handleDnsOverTcp(srcIp, srcPort, destIp, destPort, payload) }
                return
            }

            val connectionKey = "$srcIp:$srcPort-$destIp:$destPort"
            val relay = udpSockets.getOrPut(connectionKey) { UdpRelay(connectionKey, srcIp, srcPort, destIp, destPort) }
            relay.sendData(payload)
        } catch (e: Exception) { }
    }

    private fun handleDnsOverTcp(srcIp: String, srcPort: Int, destIp: String, destPort: Int, dnsPayload: ByteArray) {
        thread(name = "DNS-Worker") {
            var dnsSocket: Socket? = null
            try {
                dnsSocket = Socket()
                if (!protect(dnsSocket)) return@thread
                dnsSocket.connect(InetSocketAddress(proxyIp, proxyPort), 5000)
                val out = dnsSocket.getOutputStream()
                val ins = dnsSocket.getInputStream()

                out.write(byteArrayOf(0x05, 0x01, 0x00))
                ins.read(ByteArray(2))

                val request = byteArrayOf(0x05, 0x01, 0x00, 0x01, 8, 8, 8, 8, 0x00, 0x35)
                out.write(request)
                ins.read(ByteArray(10))

                val len = dnsPayload.size
                out.write(byteArrayOf((len shr 8).toByte(), (len and 0xFF).toByte()))
                out.write(dnsPayload)
                out.flush()

                val b1 = ins.read(); val b2 = ins.read()
                if (b1 != -1 && b2 != -1) {
                    val respLen = ((b1 and 0xFF) shl 8) or (b2 and 0xFF)
                    val respBody = ByteArray(respLen)
                    var totalRead = 0
                    while (totalRead < respLen) {
                        val r = ins.read(respBody, totalRead, respLen - totalRead)
                        if (r == -1) break
                        totalRead += r
                    }
                    val udpResponse = buildUdpPacket(destIp, destPort, srcIp, srcPort, respBody)
                    writeToVpn(udpResponse)
                }
            } catch (e: Exception) { } finally { try { dnsSocket?.close() } catch (e: Exception) {} }
        }
    }

    inner class UdpRelay(private val key: String, private val srcIp: String, private val srcPort: Int, private val destIp: String, private val destPort: Int) {
        private var socket: DatagramSocket? = null
        @Volatile var lastActivity = System.currentTimeMillis()
        private val running = AtomicBoolean(true)

        init {
            try {
                socket = DatagramSocket()
                if (!this@MyVpnService.protect(socket!!)) throw Exception("Protect failed")
                socket?.soTimeout = 5000
                connectionPool.execute { runReceiver() }
            } catch (e: Exception) { udpSockets.remove(key); close() }
        }

        fun sendData(payload: ByteArray) {
            try {
                val targetAddress = InetAddress.getByName(destIp)
                val packet = DatagramPacket(payload, payload.size, targetAddress, destPort)
                socket?.send(packet)
                lastActivity = System.currentTimeMillis()
            } catch (e: Exception) { }
        }

        private fun runReceiver() {
            val buffer = ByteArray(1460) // Optimized for 1500 MTU
            val packet = DatagramPacket(buffer, buffer.size)
            try {
                while (running.get() && isRunning) {
                    try {
                        socket?.receive(packet)
                        val responsePayload = packet.data.copyOf(packet.length)
                        val response = buildUdpPacket(destIp, destPort, srcIp, srcPort, responsePayload)
                        writeToVpn(response)
                        lastActivity = System.currentTimeMillis()
                    } catch (e: java.net.SocketTimeoutException) { } catch (e: Exception) { break }
                }
            } finally { udpSockets.remove(key); close() }
        }

        fun close() { running.set(false); try { socket?.close() } catch (e: Exception) {} }
    }

    private fun buildUdpPacket(srcIp: String, srcPort: Int, destIp: String, destPort: Int, payload: ByteArray): ByteArray {
        val totalLen = 28 + payload.size
        val packet = ByteArray(totalLen)
        packet[0] = 0x45; packet[1] = 0x00; packet[2] = (totalLen shr 8).toByte(); packet[3] = totalLen.toByte()
        packet[6] = 0x40; packet[8] = 64; packet[9] = 17
        fillIpAddresses(packet, srcIp, destIp)
        val ipChecksum = calculateChecksum(packet, 0, 20)
        packet[10] = (ipChecksum shr 8).toByte(); packet[11] = ipChecksum.toByte()
        packet[20] = (srcPort shr 8).toByte(); packet[21] = srcPort.toByte()
        packet[22] = (destPort shr 8).toByte(); packet[23] = destPort.toByte()
        val udpLen = 8 + payload.size
        packet[24] = (udpLen shr 8).toByte(); packet[25] = udpLen.toByte()
        if (payload.isNotEmpty()) System.arraycopy(payload, 0, packet, 28, payload.size)
        return packet
    }

    private fun handleTcpPacket(packet: ByteBuffer) {
        try {
            val ipHeaderLen = (packet.get(0).toInt() and 0x0F) * 4
            val ipTotalLen = ((packet.get(2).toInt() and 0xFF) shl 8) or (packet.get(3).toInt() and 0xFF)
            if (packet.limit() < ipHeaderLen + 20) return

            val srcIp = parseIpAddress(packet, 12)
            val destIp = parseIpAddress(packet, 16)
            val srcPort = ((packet.get(ipHeaderLen).toInt() and 0xFF) shl 8) or (packet.get(ipHeaderLen + 1).toInt() and 0xFF)
            val destPort = ((packet.get(ipHeaderLen + 2).toInt() and 0xFF) shl 8) or (packet.get(ipHeaderLen + 3).toInt() and 0xFF)
            val tcpHeaderLen = ((packet.get(ipHeaderLen + 12).toInt() shr 4) and 0x0F) * 4
            val tcpFlags = packet.get(ipHeaderLen + 13).toInt() and 0xFF
            val seqNum = packet.getInt(ipHeaderLen + 4)
            val ackNum = packet.getInt(ipHeaderLen + 8)
            val connectionKey = "$srcIp:$srcPort-$destIp:$destPort"
            val payloadStart = ipHeaderLen + tcpHeaderLen
            val payloadSize = ipTotalLen - ipHeaderLen - tcpHeaderLen

            val flagSYN = (tcpFlags and 0x02) != 0
            val flagACK = (tcpFlags and 0x10) != 0
            val flagFIN = (tcpFlags and 0x01) != 0
            val flagRST = (tcpFlags and 0x04) != 0

            when {
                flagRST -> tcpConnections.remove(connectionKey)?.close()
                flagSYN && !flagACK -> {
                    if (tcpConnections.containsKey(connectionKey)) return
                    val connection = TcpConnection(connectionKey, srcIp, srcPort, destIp, destPort, proxyIp, proxyPort, seqNum, ackNum)
                    tcpConnections[connectionKey] = connection
                    connectionPool.execute { connection.start() }
                }
                flagFIN -> tcpConnections[connectionKey]?.handleFIN(seqNum, ackNum)
                payloadSize > 0 -> {
                    val payload = ByteArray(payloadSize)
                    packet.position(payloadStart)
                    packet.get(payload)
                    val conn = tcpConnections[connectionKey]
                    if (conn != null) {
                        if (conn.isEstablished()) conn.sendData(payload, seqNum, ackNum)
                        else conn.queueData(payload, seqNum, ackNum)
                    }
                }
                flagACK -> tcpConnections[connectionKey]?.handleAck(ackNum)
            }
        } catch (e: Exception) { }
    }

    private fun cleanupStaleConnections() {
        while (isRunning) {
            try {
                Thread.sleep(10000)
                val now = System.currentTimeMillis()
                tcpConnections.values.removeIf { if (now - it.lastActivity > 60000) { it.close(); true } else false }
                udpSockets.values.removeIf { if (now - it.lastActivity > 30000) { it.close(); true } else false }
            } catch (e: Exception) {}
        }
    }

    private fun parseIpAddress(buffer: ByteBuffer, offset: Int): String {
        return "${buffer.get(offset).toInt() and 0xFF}.${buffer.get(offset + 1).toInt() and 0xFF}.${buffer.get(offset + 2).toInt() and 0xFF}.${buffer.get(offset + 3).toInt() and 0xFF}"
    }

    private fun fillIpAddresses(packet: ByteArray, srcIp: String, destIp: String) {
        val srcParts = srcIp.split("."); val destParts = destIp.split(".")
        for(i in 0..3) packet[12+i] = srcParts[i].toInt().toByte()
        for(i in 0..3) packet[16+i] = destParts[i].toInt().toByte()
    }

    private fun calculateChecksum(data: ByteArray, offset: Int, length: Int): Int {
        var sum = 0L; var i = offset
        while (i < offset + length - 1) {
            val high = (data[i].toInt() and 0xFF) shl 8
            val low = (data[i + 1].toInt() and 0xFF)
            sum += (high or low)
            i += 2
        }
        if (i < offset + length) sum += (data[i].toInt() and 0xFF) shl 8
        while (sum shr 16 != 0L) sum = (sum and 0xFFFF) + (sum shr 16)
        return (sum.inv() and 0xFFFF).toInt()
    }

    data class PendingPacket(val payload: ByteArray, val seq: Int, val ack: Int)

    inner class TcpConnection(
        private val key: String, private val srcIp: String, private val srcPort: Int, private val destIp: String, private val destPort: Int,
        private val proxyIp: String, private val proxyPort: Int, initialLocalSeq: Int, initialRemoteSeq: Int
    ) {
        private var socket: Socket? = null
        private val established = AtomicBoolean(false)
        @Volatile var lastActivity = System.currentTimeMillis()
        private var localSeq = initialLocalSeq.toLong()
        private var remoteSeq = initialRemoteSeq.toLong()
        private val pendingData = ArrayList<PendingPacket>()

        fun isEstablished() = established.get()
        fun queueData(payload: ByteArray, seq: Int, ack: Int) { synchronized(pendingData) { if (pendingData.size < 20) pendingData.add(PendingPacket(payload, seq, ack)) } }

        fun start() {
            try {
                socket = Socket().apply { tcpNoDelay = true; keepAlive = true; soTimeout = 30000; receiveBufferSize = 131072; sendBufferSize = 131072 }
                if (!this@MyVpnService.protect(socket!!)) throw Exception("Protect failed")
                socket?.connect(InetSocketAddress(proxyIp, proxyPort), 10000)
                val input = socket!!.getInputStream(); val output = socket!!.getOutputStream()

                output.write(byteArrayOf(0x05, 0x01, 0x00)); output.flush()
                val handshake = ByteArray(2); if (input.read(handshake) < 2 || handshake[0] != 0x05.toByte()) throw Exception("Handshake failed")

                val ipParts = destIp.split(".")
                val request = ByteArray(10)
                request[0] = 0x05; request[1] = 0x01; request[2] = 0x00; request[3] = 0x01
                for (i in 0..3) request[4 + i] = ipParts[i].toInt().toByte()
                request[8] = (destPort shr 8).toByte(); request[9] = (destPort and 0xFF).toByte()
                output.write(request); output.flush()

                val response = ByteArray(10); if (input.read(response) < 10 || response[1] != 0x00.toByte()) throw Exception("Connect failed")

                sendSynAck()
                established.set(true)
                synchronized(pendingData) { for (pending in pendingData) sendData(pending.payload, pending.seq, pending.ack); pendingData.clear() }
                connectionPool.execute { runReceiver(input) }
            } catch (e: Exception) { sendReset(); tcpConnections.remove(key); close() }
        }

        private fun runReceiver(input: java.io.InputStream) {
            val buffer = ByteArray(1460) // Optimized for 1500 MTU
            try {
                while (established.get() && isRunning) {
                    val len = input.read(buffer)
                    if (len <= 0) break
                    sendToVpn(buffer.copyOf(len))
                    lastActivity = System.currentTimeMillis()
                }
            } catch (e: Exception) { } finally { tcpConnections.remove(key); close() }
        }

        fun sendData(payload: ByteArray, seqNum: Int, ackNum: Int) {
            if (!established.get()) return
            try {
                socket?.getOutputStream()?.write(payload)
                socket?.getOutputStream()?.flush()
                localSeq = seqNum.toLong() + payload.size
                val ack = buildTcpPacket(destIp, destPort, srcIp, srcPort, remoteSeq.toInt(), localSeq.toInt(), 0x10, byteArrayOf())
                writeToVpn(ack)
                lastActivity = System.currentTimeMillis()
            } catch (e: Exception) { close() }
        }

        private fun sendToVpn(payload: ByteArray) {
            val packet = buildTcpPacket(destIp, destPort, srcIp, srcPort, remoteSeq.toInt(), localSeq.toInt(), 0x18, payload)
            writeToVpn(packet)
            remoteSeq += payload.size
        }

        private fun sendSynAck() {
            val synAck = buildTcpPacket(destIp, destPort, srcIp, srcPort, remoteSeq.toInt(), (localSeq + 1).toInt(), 0x12, byteArrayOf())
            writeToVpn(synAck)
            remoteSeq++; localSeq++
        }

        fun handleFIN(seqNum: Int, ackNum: Int) {
            localSeq = seqNum.toLong() + 1
            val finAck = buildTcpPacket(destIp, destPort, srcIp, srcPort, remoteSeq.toInt(), localSeq.toInt(), 0x11, byteArrayOf())
            writeToVpn(finAck)
            connectionPool.execute { Thread.sleep(500); tcpConnections.remove(key); close() }
        }

        fun handleAck(ackNum: Int) { lastActivity = System.currentTimeMillis() }

        private fun sendReset() {
            val rst = buildTcpPacket(destIp, destPort, srcIp, srcPort, remoteSeq.toInt(), localSeq.toInt(), 0x04, byteArrayOf())
            writeToVpn(rst)
        }

        fun close() { established.set(false); try { socket?.close() } catch (e: Exception) {} }

        private fun buildTcpPacket(srcIp: String, srcPort: Int, destIp: String, destPort: Int, seqNum: Int, ackNum: Int, flags: Int, payload: ByteArray): ByteArray {
            val totalLen = 40 + payload.size
            val packet = ByteArray(totalLen)
            packet[0] = 0x45; packet[1] = 0x00; packet[2] = (totalLen shr 8).toByte(); packet[3] = totalLen.toByte()
            packet[6] = 0x40; packet[8] = 64; packet[9] = 6
            fillIpAddresses(packet, srcIp, destIp)
            val ipChecksum = calculateChecksum(packet, 0, 20)
            packet[10] = (ipChecksum shr 8).toByte(); packet[11] = ipChecksum.toByte()
            packet[20] = (srcPort shr 8).toByte(); packet[21] = srcPort.toByte()
            packet[22] = (destPort shr 8).toByte(); packet[23] = destPort.toByte()
            packet[24] = (seqNum shr 24).toByte(); packet[25] = (seqNum shr 16).toByte(); packet[26] = (seqNum shr 8).toByte(); packet[27] = seqNum.toByte()
            packet[28] = (ackNum shr 24).toByte(); packet[29] = (ackNum shr 16).toByte(); packet[30] = (ackNum shr 8).toByte(); packet[31] = ackNum.toByte()
            packet[32] = 0x50; packet[33] = flags.toByte();
            packet[34] = 0xFF.toByte(); packet[35] = 0xFF.toByte() // Max Window Size for Speed
            if (payload.isNotEmpty()) System.arraycopy(payload, 0, packet, 40, payload.size)
            val tcpChecksum = calculateTcpChecksum(packet, 20, 20 + payload.size, srcIp, destIp)
            packet[36] = (tcpChecksum shr 8).toByte(); packet[37] = tcpChecksum.toByte()
            return packet
        }

        private fun calculateTcpChecksum(packet: ByteArray, tcpOffset: Int, tcpLen: Int, srcIp: String, destIp: String): Int {
            val pseudoHeader = ByteArray(12 + tcpLen)
            val srcParts = srcIp.split("."); val destParts = destIp.split(".")
            for(i in 0..3) pseudoHeader[i] = srcParts[i].toInt().toByte()
            for(i in 0..3) pseudoHeader[4+i] = destParts[i].toInt().toByte()
            pseudoHeader[9] = 6; pseudoHeader[10] = (tcpLen shr 8).toByte(); pseudoHeader[11] = tcpLen.toByte()
            System.arraycopy(packet, tcpOffset, pseudoHeader, 12, tcpLen)
            return calculateChecksum(pseudoHeader, 0, pseudoHeader.size)
        }
    }

    private fun startForegroundNotification() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel("vpn_channel", "VPN Service", NotificationManager.IMPORTANCE_LOW)
            getSystemService(NotificationManager::class.java).createNotificationChannel(channel)
        }
        val notification = NotificationCompat.Builder(this, "vpn_channel").setContentTitle("VPN Running").setSmallIcon(android.R.drawable.ic_dialog_info).build()
        startForeground(1, notification)
    }

    private fun updateNotification(message: String) {
        val notification = NotificationCompat.Builder(this, "vpn_channel").setContentTitle("VPN Service").setContentText(message).setSmallIcon(android.R.drawable.ic_dialog_info).build()
        getSystemService(NotificationManager::class.java).notify(1, notification)
    }

    override fun onDestroy() {
        isRunning = false; connectionPool.shutdownNow()
        tcpConnections.values.forEach { it.close() }; tcpConnections.clear()
        udpSockets.values.forEach { it.close() }; udpSockets.clear()
        vpnWriter?.close(); vpnInterface?.close()
        super.onDestroy()
    }
}

============================================================
FILE: app\src\main\java\com\example\hotspot_bypass_vpn\ProxyServer.kt
============================================================

package com.example.hotspot_bypass_vpn

import android.util.Log
import java.io.InputStream
import java.io.OutputStream
import java.net.InetAddress
import java.net.ServerSocket
import java.net.Socket
import java.net.InetSocketAddress
import java.util.concurrent.Executors
import kotlin.concurrent.thread

class ProxyServer {
    private var serverSocket: ServerSocket? = null
    private var isRunning = false
    private val PORT = 8080

    // Thread pool for handling clients
    private val clientPool = Executors.newCachedThreadPool() // No fixed limit

    fun start() {
        if (isRunning) {
            Log.w("ProxyServer", "Server already running")
            return
        }
        isRunning = true

        thread(name = "ProxyServer-Main", isDaemon = true) {
            try {
                serverSocket = ServerSocket()
                serverSocket?.reuseAddress = true
                serverSocket?.receiveBufferSize = 65536 // Larger buffer

                val bindAddress = InetSocketAddress("0.0.0.0", PORT)
                serverSocket?.bind(bindAddress, 50)

                Log.d("ProxyServer", "✓ SERVER STARTED")
                Log.d("ProxyServer", "✓ Listening on 0.0.0.0:$PORT")

                while (isRunning && serverSocket?.isClosed == false) {
                    try {
                        val client = serverSocket?.accept()
                        if (client != null) {
                            // Configure socket for performance
                            client.tcpNoDelay = true
                            client.keepAlive = true
                            client.soTimeout = 30000
                            client.receiveBufferSize = 65536
                            client.sendBufferSize = 65536

                            Log.d("ProxyServer", "✓ Client: ${client.inetAddress.hostAddress}:${client.port}")

                            // Handle in thread pool
                            clientPool.execute {
                                handleClient(client)
                            }
                        }
                    } catch (e: Exception) {
                        if (isRunning) {
                            Log.e("ProxyServer", "Accept error: ${e.message}")
                        }
                    }
                }
            } catch (e: Exception) {
                Log.e("ProxyServer", "✗ Server Error", e)
            }
        }
    }

    fun stop() {
        Log.d("ProxyServer", "Stopping server...")
        isRunning = false

        clientPool.shutdown()

        try {
            serverSocket?.close()
            Log.d("ProxyServer", "Server stopped")
        } catch (e: Exception) {
            Log.e("ProxyServer", "Error stopping: ${e.message}")
        }
    }

    private fun handleClient(client: Socket) {
        val clientId = "${client.inetAddress.hostAddress}:${client.port}"
        try {
            val input = client.getInputStream()
            val output = client.getOutputStream()

            // SOCKS5 Handshake
            val version = input.read()
            if (version == -1) return // Client closed connection during health check
            if (version != 5) {
                Log.e("ProxyServer", "[$clientId] ✗ Invalid version: $version")
                client.close()
                return
            }

            val nMethods = input.read()
            if (nMethods > 0) {
                val methods = ByteArray(nMethods)
                input.read(methods) // Read and discard the methods
            }

            output.write(byteArrayOf(0x05, 0x00))
            output.flush()

            // SOCKS5 Request
            if (input.read() != 5) {
                client.close()
                return
            }

            val cmd = input.read()
            if (cmd != 1) {
                Log.e("ProxyServer", "[$clientId] ✗ Unsupported cmd: $cmd")
                client.close()
                return
            }

            input.read() // skip reserved
            val atyp = input.read()

            var targetHost = ""
            when (atyp) {
                1 -> { // IPv4
                    val ipBytes = ByteArray(4)
                    input.read(ipBytes)
                    targetHost = InetAddress.getByAddress(ipBytes).hostAddress ?: ""
                }
                3 -> { // Domain
                    val len = input.read()
                    val domainBytes = ByteArray(len)
                    input.read(domainBytes)
                    targetHost = String(domainBytes)
                }
                else -> {
                    Log.e("ProxyServer", "[$clientId] ✗ Unsupported atyp: $atyp")
                    client.close()
                    return
                }
            }

            val portBytes = ByteArray(2)
            input.read(portBytes)
            val targetPort = ((portBytes[0].toInt() and 0xFF) shl 8) or (portBytes[1].toInt() and 0xFF)

            // Connect to target
            val targetSocket = Socket()
            try {
                // Optimize target socket too
                targetSocket.tcpNoDelay = true
                targetSocket.receiveBufferSize = 65536
                targetSocket.sendBufferSize = 65536

                targetSocket.connect(InetSocketAddress(targetHost, targetPort), 10000)
                Log.d("ProxyServer", "[$clientId] ✓ → $targetHost:$targetPort")

                // Send success
                val response = byteArrayOf(
                    0x05, 0x00, 0x00, 0x01,
                    0, 0, 0, 0, 0, 0
                )
                output.write(response)
                output.flush()

                // Bidirectional relay with larger buffers
                val clientToTarget = thread(name = "C2T-$clientId", isDaemon = true) {
                    pipe(input, targetSocket.getOutputStream(), 16384)
                    try { targetSocket.shutdownOutput() } catch (e: Exception) {}
                }

                val targetToClient = thread(name = "T2C-$clientId", isDaemon = true) {
                    pipe(targetSocket.getInputStream(), output, 16384)
                    try { client.shutdownOutput() } catch (e: Exception) {}
                }

                clientToTarget.join()
                targetToClient.join()

            } catch (e: Exception) {
                Log.e("ProxyServer", "[$clientId] ✗ Connect failed: ${e.message}")
                try {
                    val response = byteArrayOf(0x05, 0x01, 0x00, 0x01, 0, 0, 0, 0, 0, 0)
                    output.write(response)
                    output.flush()
                } catch (e2: Exception) {}
            } finally {
                targetSocket.close()
            }

        } catch (e: Exception) {
            Log.e("ProxyServer", "[$clientId] ✗ Error: ${e.message}")
        } finally {
            try {
                client.close()
            } catch (e: Exception) {}
        }
    }

    private fun pipe(ins: InputStream, out: OutputStream, bufferSize: Int = 16384) {
        val buffer = ByteArray(bufferSize) // Larger buffer = better throughput
        try {
            var len: Int
            while (ins.read(buffer).also { len = it } != -1) {
                out.write(buffer, 0, len)
                // Don't flush on every write - let TCP do batching
                if (len < bufferSize / 2) {
                    out.flush() // Only flush on small writes
                }
            }
        } catch (e: Exception) {
            // Connection closed
        }
    }
}

============================================================
FILE: app\src\main\java\com\example\hotspot_bypass_vpn\WiFiDirectBroadcastReceiver.kt
============================================================

package com.example.hotspot_bypass_vpn

import android.Manifest
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.NetworkInfo
import android.net.wifi.p2p.WifiP2pManager
import android.os.Build
import androidx.core.app.ActivityCompat

class WiFiDirectBroadcastReceiver(
    private val manager: WifiP2pManager,
    private val channel: WifiP2pManager.Channel,
    private val activity: MainActivity
) : BroadcastReceiver() {

    override fun onReceive(context: Context, intent: Intent) {
        when (intent.action) {
            WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION -> {
                val state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1)
                // Optional: Notify activity if Wifi P2P is disabled
                if (state != WifiP2pManager.WIFI_P2P_STATE_ENABLED) {
                    // Wi-Fi Direct is OFF
                }
            }
            WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION -> {
                // We don't need this for the Host, but if you scan for peers,
                // you would check permissions here too.
            }
            WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION -> {
                val networkInfo = intent.getParcelableExtra<NetworkInfo>(WifiP2pManager.EXTRA_NETWORK_INFO)

                if (networkInfo?.isConnected == true) {
                    // --- PERMISSION CHECK START ---
                    // We must check if we have permission before asking for IP/Password

                    // 1. Check for Fine Location (Required for all versions)
                    if (ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION)
                        != PackageManager.PERMISSION_GRANTED) {
                        return // Exit if permission is missing
                    }

                    // 2. Check for Nearby Devices (Required for Android 13+)
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.NEARBY_WIFI_DEVICES)
                            != PackageManager.PERMISSION_GRANTED) {
                            return // Exit if permission is missing
                        }
                    }
                    // --- PERMISSION CHECK END ---

                    // If we passed the checks, it is safe to call these:
                    manager.requestConnectionInfo(channel, activity)

                    manager.requestGroupInfo(channel) { group ->
                        // Send the group info (Password/SSID) back to MainActivity
                        activity.updateGroupInfo(group)
                    }
                }
            }
            WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION -> {
                // Respond to this device's wifi state changing
            }
        }
    }
}

============================================================
FILE: app\src\main\res\layout\activity_main.xml
============================================================

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    tools:context=".MainActivity">

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:gravity="center_horizontal">

            <!-- APP TITLE -->
            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Hotspot Bypass VPN"
                android:textSize="24sp"
                android:textStyle="bold"
                android:layout_marginBottom="24dp"/>

            <!-- SECTION 1: HOST (SHARE INTERNET) -->
            <androidx.cardview.widget.CardView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                app:cardCornerRadius="8dp"
                app:cardElevation="4dp"
                android:layout_marginBottom="24dp">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:padding="16dp">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="MODE A: HOST (Share Internet)"
                        android:textStyle="bold"
                        android:textColor="@color/black"
                        android:layout_marginBottom="8dp"/>

                    <TextView
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="1. Turn on Mobile Data.\n2. Click Start to create a Wi-Fi Group."
                        android:textSize="12sp"
                        android:layout_marginBottom="12dp"/>

                    <Button
                        android:id="@+id/btn_start_host"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="Start Sharing"
                        android:backgroundTint="#2196F3"/>

                    <!-- This text will update with SSID/Pass when you click Start -->
                    <TextView
                        android:id="@+id/tv_host_info"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="Status: Stopped"
                        android:background="#EEE"
                        android:padding="8dp"
                        android:layout_marginTop="8dp"
                        android:fontFamily="monospace"/>
                </LinearLayout>
            </androidx.cardview.widget.CardView>

            <!-- SECTION 2: CLIENT (CONNECT) -->
            <androidx.cardview.widget.CardView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                app:cardCornerRadius="8dp"
                app:cardElevation="4dp">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:padding="16dp">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="MODE B: CLIENT (Connect)"
                        android:textStyle="bold"
                        android:textColor="@color/black"
                        android:layout_marginBottom="8dp"/>

                    <TextView
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="1. Connect to the Host's Wi-Fi manually.\n2. Enter IP Address from Host screen below.\n3. Click Connect to start VPN."
                        android:textSize="12sp"
                        android:layout_marginBottom="12dp"/>

                    <EditText
                        android:id="@+id/et_host_ip"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:hint="Host IP (e.g., 192.168.49.1)"
                        android:text="192.168.49.1"
                        android:inputType="text"
                        android:digits="0123456789." />

                    <EditText
                        android:id="@+id/et_host_port"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:hint="Port (e.g., 8080)"
                        android:inputType="number"
                        android:text="8080"/>

                    <Button
                        android:id="@+id/btn_connect"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="Connect &amp; Start VPN"
                        android:backgroundTint="#4CAF50"
                        android:layout_marginTop="8dp"/>
                </LinearLayout>
            </androidx.cardview.widget.CardView>

            <!-- DEBUG LOGS -->
            <TextView
                android:id="@+id/tv_status_log"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="Logs will appear here..."
                android:layout_marginTop="24dp"
                android:padding="8dp"
                android:textColor="#555"/>

            <Button
                android:id="@+id/btn_debug"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="Debug Test"
                android:backgroundTint="#FF9800" />

        </LinearLayout>
    </ScrollView>
</androidx.constraintlayout.widget.ConstraintLayout>
