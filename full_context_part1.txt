
============================================================
FILE: build.gradle.kts
============================================================

// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    alias(libs.plugins.android.application) apply false
    alias(libs.plugins.kotlin.android) apply false
}

============================================================
FILE: settings.gradle.kts
============================================================

pluginManagement {
    repositories {
        google()
        mavenCentral()
        gradlePluginPortal()
    }
}
dependencyResolutionManagement {
    repositoriesMode.set(RepositoriesMode.FAIL_ON_PROJECT_REPOS)
    repositories {
        google()
        mavenCentral()
        // Try the standard jitpack again with a fresh proxy setting
        maven { url = uri("https://jitpack.io") }
    }
}

rootProject.name = "Hotspot-Bypass-VPN"
include(":app")

============================================================
FILE: app\build.gradle.kts
============================================================

plugins {
    alias(libs.plugins.android.application)
    alias(libs.plugins.kotlin.android)
}

android {
    namespace = "com.example.hotspot_bypass_vpn"
    compileSdk = 35

    defaultConfig {
        applicationId = "com.example.hotspot_bypass_vpn"
        minSdk = 24
        targetSdk = 35
        versionCode = 1
        versionName = "1.0"

        testInstrumentationRunner = "androidx.test.runner.AndroidJUnitRunner"

        ndk {
            abiFilters.addAll(listOf("armeabi-v7a", "arm64-v8a", "x86", "x86_64"))
        }
    }

    buildTypes {
        release {
            isMinifyEnabled = false
            proguardFiles(
                getDefaultProguardFile("proguard-android-optimize.txt"),
                "proguard-rules.pro"
            )
        }
    }

    compileOptions {
        sourceCompatibility = JavaVersion.VERSION_11
        targetCompatibility = JavaVersion.VERSION_11
    }

    kotlinOptions {
        jvmTarget = "11"
    }
}

dependencies {
    implementation(libs.androidx.core.ktx)
    implementation(libs.androidx.appcompat)
    implementation(libs.material)
    implementation(libs.androidx.activity)
    implementation(libs.androidx.constraintlayout)
    testImplementation(libs.junit)
    androidTestImplementation(libs.androidx.junit)
    androidTestImplementation(libs.androidx.espresso.core)

    // OkHttp for SOCKS proxy support
    implementation("com.squareup.okhttp3:okhttp:4.12.0")

    // Local AAR library - tun2socks
    implementation(files("libs/tun2socks-1.0.4.aar"))

    // Alternative libbox (if you want to keep it as backup)
    // implementation("io.nekohasekai:libbox:1.8.0")
}

============================================================
FILE: app\src\main\AndroidManifest.xml
============================================================

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    <uses-permission android:name="android.permission.CHANGE_NETWORK_STATE" />
    <uses-permission android:name="android.permission.ACCESS_WIFI_STATE" />
    <uses-permission android:name="android.permission.CHANGE_WIFI_STATE" />
    <uses-permission android:name="android.permission.NEARBY_WIFI_DEVICES"
        android:usesPermissionFlags="neverForLocation" />
    <uses-permission android:name="android.permission.ACCESS_FINE_LOCATION" />
    <uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE_SPECIAL_USE" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <uses-permission android:name="android.permission.POST_NOTIFICATIONS" />

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.HotspotBypassVPN">
        <activity
            android:name=".MainActivity"
            android:exported="true">
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
        </activity>

        <!-- NEW: tun2socks VPN Service -->
        <service
            android:name=".MyVpnServiceTun2Socks"
            android:permission="android.permission.BIND_VPN_SERVICE"
            android:foregroundServiceType="specialUse"
            android:exported="false">
            <intent-filter>
                <action android:name="android.net.VpnService" />
            </intent-filter>
            <property
                android:name="android.app.PROPERTY_SPECIAL_USE_FGS_SUBTYPE"
                android:value="VPN proxy using tun2socks" />
        </service>

        <!-- KEEP: Original optimized service (optional backup) -->
        <service
            android:name=".MyVpnServiceOptimized"
            android:permission="android.permission.BIND_VPN_SERVICE"
            android:foregroundServiceType="specialUse"
            android:exported="false"
            android:enabled="false">
            <intent-filter>
                <action android:name="android.net.VpnService" />
            </intent-filter>
            <property
                android:name="android.app.PROPERTY_SPECIAL_USE_FGS_SUBTYPE"
                android:value="VPN proxy for hotspot bypass" />
        </service>
    </application>

</manifest>

============================================================
FILE: app\src\main\java\com\example\hotspot_bypass_vpn\DebugUtils.kt
============================================================

package com.example.hotspot_bypass_vpn

import android.util.Log
import java.net.InetAddress
import java.net.InetSocketAddress
import java.net.Socket
import java.util.concurrent.atomic.AtomicInteger

object DebugUtils {
    private const val TAG = "VPN_DEBUG"
    private val connectionCounter = AtomicInteger(0)

    fun log(message: String) {
        Log.d(TAG, "[${Thread.currentThread().name}] $message")
    }

    fun error(message: String, e: Throwable? = null) {
        Log.e(TAG, "[${Thread.currentThread().name}] $message", e)
    }

    fun testProxyConnection(proxyIp: String, proxyPort: Int): Boolean {
        return try {
            log("Testing connection to proxy: $proxyIp:$proxyPort")
            val socket = Socket()
            socket.connect(InetSocketAddress(proxyIp, proxyPort), 5000)
            socket.close()
            log("✓ Proxy connection test PASSED")
            true
        } catch (e: Exception) {
            error("✗ Proxy connection test FAILED: ${e.message}")
            false
        }
    }

    fun testInternetConnectivity(): Boolean {
        return try {
            log("Testing internet connectivity")
            val socket = Socket()
            socket.connect(InetSocketAddress("8.8.8.8", 53), 3000)
            socket.close()
            log("✓ Internet connectivity test PASSED")
            true
        } catch (e: Exception) {
            error("✗ Internet connectivity test FAILED: ${e.message}")
            false
        }
    }

    fun dumpVpnStats(
        tcpConnections: Map<*, *>,
        udpSockets: Map<*, *>,
        writeQueueSize: Int,
        poolActiveCount: Int,
        poolQueueSize: Int
    ) {
        log("VPN Stats:")
        log("  TCP Connections: ${tcpConnections.size}")
        log("  UDP Sockets: ${udpSockets.size}")
        log("  Write Queue: $writeQueueSize")
        log("  Pool Active: $poolActiveCount")
        log("  Pool Queue: $poolQueueSize")
    }
}

============================================================
FILE: app\src\main\java\com\example\hotspot_bypass_vpn\Dnscache.kt
============================================================

package com.example.hotspot_bypass_vpn

import java.net.InetAddress
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.TimeUnit

/**
 * DNS Cache to avoid repeated slow lookups
 * This can reduce DNS query time from 500ms+ to <1ms for cached entries
 */
class DnsCache {
    private data class CacheEntry(
        val address: ByteArray,
        val timestamp: Long,
        val ttl: Long = TimeUnit.MINUTES.toMillis(5) // 5 minute default TTL
    ) {
        fun isExpired(): Boolean = System.currentTimeMillis() - timestamp > ttl
    }

    private val cache = ConcurrentHashMap<String, CacheEntry>()

    // Pre-populate with common domains
    init {
        // These will be resolved on first use, then cached
        preWarm(listOf(
            "www.google.com",
            "www.facebook.com",
            "www.instagram.com",
            "www.youtube.com",
            "api.instagram.com",
            "i.instagram.com"
        ))
    }

    private fun preWarm(domains: List<String>) {
        Thread {
            domains.forEach { domain ->
                try {
                    val addr = InetAddress.getByName(domain)
                    put(domain, addr.address)
                } catch (e: Exception) {
                    // Ignore pre-warm failures
                }
            }
        }.start()
    }

    fun get(domain: String): ByteArray? {
        val entry = cache[domain]
        return if (entry != null && !entry.isExpired()) {
            entry.address
        } else {
            cache.remove(domain)
            null
        }
    }

    fun put(domain: String, address: ByteArray, ttl: Long = TimeUnit.MINUTES.toMillis(5)) {
        cache[domain] = CacheEntry(address, System.currentTimeMillis(), ttl)
    }

    fun clear() {
        cache.clear()
    }

    fun size() = cache.size
}

============================================================
FILE: app\src\main\java\com\example\hotspot_bypass_vpn\MainActivity.kt
============================================================

package com.example.hotspot_bypass_vpn

import android.Manifest
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.pm.PackageManager
import android.net.VpnService
import android.net.wifi.p2p.WifiP2pGroup
import android.net.wifi.p2p.WifiP2pInfo
import android.net.wifi.p2p.WifiP2pManager
import android.os.Build
import android.os.Bundle
import android.widget.Button
import android.widget.EditText
import android.widget.TextView
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import kotlin.concurrent.thread
import android.content.DialogInterface
import android.location.LocationManager
import android.net.wifi.WifiManager
import android.provider.Settings
import androidx.appcompat.app.AlertDialog

class MainActivity : AppCompatActivity(), WifiP2pManager.ConnectionInfoListener {

    private val proxyServer = ProxyServer()

    private lateinit var manager: WifiP2pManager
    private lateinit var channel: WifiP2pManager.Channel
    private lateinit var receiver: BroadcastReceiver
    private val intentFilter = IntentFilter()

    private lateinit var tvHostInfo: TextView
    private lateinit var tvStatusLog: TextView
    private lateinit var etIp: EditText
    private lateinit var etPort: EditText

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        val btnStartHost = findViewById<Button>(R.id.btn_start_host)
        val btnStopHost = findViewById<Button>(R.id.btn_stop_host)
        val btnConnect = findViewById<Button>(R.id.btn_connect)
        val btnStopClient = findViewById<Button>(R.id.btn_stop_client)
        val btnDebug = findViewById<Button>(R.id.btn_debug)
        tvHostInfo = findViewById(R.id.tv_host_info)
        tvStatusLog = findViewById(R.id.tv_status_log)
        etIp = findViewById(R.id.et_host_ip)
        etPort = findViewById(R.id.et_host_port)

        manager = getSystemService(Context.WIFI_P2P_SERVICE) as WifiP2pManager
        channel = manager.initialize(this, mainLooper, null)

        intentFilter.addAction(WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION)
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION)
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION)
        intentFilter.addAction(WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION)

        checkPermissions()

        btnStartHost.setOnClickListener {
            if (!isWifiEnabled()) {
                showEnableServiceDialog(
                    "Wi-Fi Required",
                    "Wi-Fi must be turned ON to share internet via Wi-Fi Direct.",
                    Settings.ACTION_WIFI_SETTINGS
                )
                return@setOnClickListener
            }

            if (!isLocationEnabled()) {
                showEnableServiceDialog(
                    "Location Required",
                    "System Location (GPS) must be ON for Android to allow Wi-Fi Direct group creation.",
                    Settings.ACTION_LOCATION_SOURCE_SETTINGS
                )
                return@setOnClickListener
            }

            startHost()
        }

        btnStopHost.setOnClickListener {
            stopHost()
        }

        btnDebug.setOnClickListener {
            runInternetPingTest()
        }

        btnConnect.setOnClickListener {
            if (!isWifiEnabled()) {
                showEnableServiceDialog(
                    "Wi-Fi Required",
                    "Please turn on Wi-Fi and connect to the Host phone first.",
                    Settings.ACTION_WIFI_SETTINGS
                )
                return@setOnClickListener
            }

            if (!isLocationEnabled()) {
                showEnableServiceDialog("Location Required", "Location must be ON to identify the Wi-Fi network properly.", Settings.ACTION_LOCATION_SOURCE_SETTINGS)
                return@setOnClickListener
            }

            val ip = etIp.text.toString()
            val portStr = etPort.text.toString()

            if (ip.isEmpty() || portStr.isEmpty()) {
                Toast.makeText(this, "Please enter IP and Port", Toast.LENGTH_SHORT).show()
                return@setOnClickListener
            }

            val port = portStr.toIntOrNull() ?: 8080
            testConnectivity(ip, port)
            prepareVpn(ip, port)
        }

        btnStopClient.setOnClickListener {
            stopVpnService()
        }
    }

    private fun stopHost() {
        log("Stopping Host...")
        proxyServer.stop()

        manager.removeGroup(channel, object : WifiP2pManager.ActionListener {
            override fun onSuccess() {
                log("✓ Wi-Fi Group removed")
                tvHostInfo.text = "Status: Stopped"
            }
            override fun onFailure(reason: Int) {
                log("✗ Failed to remove group: $reason")
            }
        })
    }

    private fun stopVpnService() {
        log("Stopping VPN Service...")
        val intent = Intent(this, MyVpnServiceTun2Socks::class.java)
        stopService(intent)
        log("✓ VPN stop signal sent")
    }

    private fun prepareVpn(ip: String, port: Int) {
        val intent = VpnService.prepare(this)
        if (intent != null) {
            startActivityForResult(intent, 102)
        } else {
            startVpnService(ip, port)
        }
    }

    private fun startVpnService(ip: String, port: Int) {
        // Use the new tun2socks service
        val intent = Intent(this, MyVpnServiceTun2Socks::class.java).apply {
            putExtra("PROXY_IP", ip)
            putExtra("PROXY_PORT", port)
        }
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            startForegroundService(intent)
        } else {
            startService(intent)
        }
        log("VPN Client Starting with tun2socks... Connecting to $ip:$port")
    }

    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
        super.onActivityResult(requestCode, resultCode, data)
        if (requestCode == 102 && resultCode == RESULT_OK) {
            val ip = etIp.text.toString()
            val port = etPort.text.toString().toInt()
            startVpnService(ip, port)
        }
    }

    private fun startHost() {
        manager.removeGroup(channel, object : WifiP2pManager.ActionListener {
            override fun onSuccess() { createNewGroup() }
            override fun onFailure(reason: Int) { createNewGroup() }
        })
    }

    private fun createNewGroup() {
        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED) {
            log("Permission Error")
            return
        }
        manager.createGroup(channel, object : WifiP2pManager.ActionListener {
            override fun onSuccess() { log("Creating Group...") }
            override fun onFailure(reason: Int) { log("Error: $reason") }
        })
    }

    override fun onConnectionInfoAvailable(info: WifiP2pInfo?) {
        if (info != null && info.groupFormed) {
            val hostIp = info.groupOwnerAddress?.hostAddress ?: "192.168.49.1"
            log("NETWORK ACTIVE. Host IP: $hostIp")
        }
    }

    fun updateGroupInfo(group: WifiP2pGroup?) {
        if (group != null && group.isGroupOwner) {
            proxyServer.start()
            tvHostInfo.text = "SSID: ${group.networkName}\nPASS: ${group.passphrase}\nIP: 192.168.49.1\nPORT: 8080"
            log("Proxy Running with tun2socks support")
        }
    }

    private val logReceiver = object : BroadcastReceiver() {
        override fun onReceive(context: Context?, intent: Intent?) {
            val message = intent?.getStringExtra("message") ?: ""
            log(message)
        }
    }

    override fun onResume() {
        super.onResume()
        receiver = WiFiDirectBroadcastReceiver(manager, channel, this)
        registerReceiver(receiver, intentFilter)
        ContextCompat.registerReceiver(
            this,
            logReceiver,
            IntentFilter("VPN_LOG"),
            ContextCompat.RECEIVER_NOT_EXPORTED
        )
    }

    override fun onPause() {
        super.onPause()
        try {
            unregisterReceiver(receiver)
        } catch (e: IllegalArgumentException) {}
        try {
            unregisterReceiver(logReceiver)
        } catch (e: IllegalArgumentException) {}
    }

    override fun onDestroy() {
        super.onDestroy()
        proxyServer.stop()
        manager.removeGroup(channel, null)
    }

    private fun checkPermissions() {
        val permissions = mutableListOf(
            Manifest.permission.ACCESS_FINE_LOCATION,
            Manifest.permission.CHANGE_WIFI_STATE,
            Manifest.permission.ACCESS_WIFI_STATE
        )
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            permissions.add(Manifest.permission.NEARBY_WIFI_DEVICES)
            permissions.add(Manifest.permission.POST_NOTIFICATIONS)
        }
        ActivityCompat.requestPermissions(this, permissions.toTypedArray(), 101)
    }

    private fun log(message: String) {
        runOnUiThread {
            val currentText = tvStatusLog.text.toString()
            tvStatusLog.text = "$message\n$currentText"
        }
    }

    private fun testConnectivity(ip: String, port: Int) {
        thread {
            try {
                DebugUtils.log("Starting connectivity test...")
                val canConnect = DebugUtils.testProxyConnection(ip, port)
                runOnUiThread {
                    if (canConnect) {
                        Toast.makeText(this, "✓ Can connect to proxy", Toast.LENGTH_SHORT).show()
                        log("Connectivity test PASSED")
                    } else {
                        Toast.makeText(this, "✗ Cannot connect to proxy", Toast.LENGTH_SHORT).show()
                        log("Connectivity test FAILED")
                    }
                }
            } catch (e: Exception) {
                runOnUiThread {
                    log("Test error: ${e.message}")
                }
            }
        }
    }

    private fun runInternetPingTest() {
        log("--- Starting Connectivity Test ---")
        thread {
            try {
                val host = "8.8.8.8"
                val port = 53
                val timeout = 5000
                val startTime = System.currentTimeMillis()

                val socket = java.net.Socket()
                socket.connect(java.net.InetSocketAddress(host, port), timeout)
                val endTime = System.currentTimeMillis()
                socket.close()

                log("✓ Internet Reachable: Connected to $host in ${endTime - startTime}ms")
            } catch (e: Exception) {
                log("✗ Internet Unreachable: ${e.message}")
            }

            try {
                log("Testing DNS resolution (google.com)...")
                val dnsStart = System.currentTimeMillis()
                val address = java.net.InetAddress.getByName("google.com")
                val dnsEnd = System.currentTimeMillis()
                log("✓ DNS Success: google.com -> ${address.hostAddress} (${dnsEnd - dnsStart}ms)")
            } catch (e: Exception) {
                log("✗ DNS Failed: ${e.message}")
            }
        }
    }

    private fun isWifiEnabled(): Boolean {
        val wifiManager = applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager
        return wifiManager.isWifiEnabled
    }

    private fun isLocationEnabled(): Boolean {
        val locationManager = getSystemService(Context.LOCATION_SERVICE) as LocationManager
        return locationManager.isProviderEnabled(LocationManager.GPS_PROVIDER)
    }

    private fun showEnableServiceDialog(title: String, message: String, settingsAction: String) {
        AlertDialog.Builder(this)
            .setTitle(title)
            .setMessage(message)
            .setPositiveButton("Go to Settings") { _, _ ->
                startActivity(Intent(settingsAction))
            }
            .setNegativeButton("Cancel", null)
            .show()
    }
}

============================================================
FILE: app\src\main\java\com\example\hotspot_bypass_vpn\MyVpnService.kt
============================================================

package com.example.hotspot_bypass_vpn

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Intent
import android.net.VpnService
import android.os.Build
import android.os.ParcelFileDescriptor
import androidx.core.app.NotificationCompat
import java.io.FileInputStream
import java.io.FileOutputStream
import java.net.*
import java.nio.ByteBuffer
import java.nio.channels.DatagramChannel
import java.nio.channels.SocketChannel
import java.util.concurrent.*
import java.util.concurrent.atomic.AtomicBoolean
import java.util.concurrent.atomic.AtomicInteger
import java.util.concurrent.atomic.AtomicLong
import kotlin.concurrent.thread

class MyVpnService : VpnService() {

    private var vpnInterface: ParcelFileDescriptor? = null
    private var isRunning = false
    private var proxyIp = ""
    private var proxyPort = 0

    private val tcpConnections = ConcurrentHashMap<String, TcpConnection>()
    private val udpSockets = ConcurrentHashMap<String, UdpRelay>()

    // ULTRA-OPTIMIZED: Even larger pool with priority queue
    private val fastPool = ThreadPoolExecutor(
        50, 1000, 30L, TimeUnit.SECONDS,
        LinkedBlockingQueue(20000),
        ThreadFactory { r -> Thread(r).apply { priority = Thread.MAX_PRIORITY } },
        ThreadPoolExecutor.CallerRunsPolicy()
    )

    // Separate pool for packet reading (high priority)
    private val readerPool = Executors.newFixedThreadPool(4, ThreadFactory { r ->
        Thread(r).apply { priority = Thread.MAX_PRIORITY; name = "PacketReader-${Thread.currentThread().id}" }
    })

    // ULTRA-OPTIMIZED: Massive queue with lock-free operations
    private val vpnWriteQueue = LinkedBlockingQueue<ByteArray>(50000)
    private var vpnWriter: FileOutputStream? = null

    // DNS Cache to avoid repeated lookups
    private val dnsCache = ConcurrentHashMap<String, InetAddress>()

    // Connection statistics
    private val stats = Stats()

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        proxyIp = intent?.getStringExtra("PROXY_IP") ?: "192.168.49.1"
        proxyPort = intent?.getIntExtra("PROXY_PORT", 8080) ?: 8080

        startForegroundNotification()

        thread(name = "ProxyTest") {
            if (DebugUtils.testProxyConnection(proxyIp, proxyPort)) {
                startVpnInterface()
            } else {
                updateNotification("Error: Cannot reach proxy")
                stopSelf()
            }
        }
        return START_STICKY
    }

    private fun startVpnInterface() {
        val builder = Builder()
            .setMtu(1500)
            .addAddress("10.0.0.2", 32)
            .addRoute("0.0.0.0", 0)
            .addDisallowedApplication(packageName)
            .addDnsServer("8.8.8.8")
            .addDnsServer("1.1.1.1")
            .setBlocking(false)
            .setSession("Instagram Optimized VPN")

        vpnInterface = builder.establish()

        if (vpnInterface != null) {
            isRunning = true
            updateNotification("⚡ VPN Active - Optimized")

            // Start multiple writer threads for parallel processing
            repeat(2) { i ->
                thread(name = "VPN-Writer-$i", isDaemon = true) { runVpnWriterUltraFast() }
            }

            // Start multiple reader threads for parallel packet processing
            repeat(4) { i ->
                thread(name = "VPN-Reader-$i", isDaemon = true) { readPacketsParallel() }
            }

            thread(name = "Cleanup", isDaemon = true) { cleanupStaleConnections() }
            thread(name = "Stats", isDaemon = true) { printStats() }
        }
    }

    // ULTRA-OPTIMIZED: Lock-free batch writing with minimal latency
    private fun runVpnWriterUltraFast() {
        vpnWriter = FileOutputStream(vpnInterface!!.fileDescriptor)
        val batch = ArrayList<ByteArray>(200)

        try {
            while (isRunning) {
                batch.clear()

                // Non-blocking poll with timeout
                val first = vpnWriteQueue.poll(5, TimeUnit.MILLISECONDS)
                if (first != null) {
                    batch.add(first)
                    vpnWriteQueue.drainTo(batch, 199) // Get up to 199 more instantly

                    // Write entire batch at once
                    synchronized(vpnWriter!!) {
                        for (packet in batch) {
                            vpnWriter?.write(packet)
                        }
                        vpnWriter?.flush()
                    }
                    stats.packetsSent.addAndGet(batch.size)
                }
            }
        } catch (e: Exception) {
            DebugUtils.error("VPN Writer error", e)
        }
    }

    private fun writeToVpn(packet: ByteArray) {
        if (!vpnWriteQueue.offer(packet)) {
            stats.packetsDropped.incrementAndGet()
            // Drop oldest, retry
            vpnWriteQueue.poll()
            vpnWriteQueue.offer(packet)
        }
    }

    // ULTRA-OPTIMIZED: Parallel packet reading with zero-copy buffers
    private fun readPacketsParallel() {
        val inputStream = FileInputStream(vpnInterface!!.fileDescriptor)
        val buffer = ByteBuffer.allocateDirect(131072) // 128KB direct buffer
        val array = ByteArray(131072)

        try {
            while (isRunning) {
                val length = inputStream.read(array)
                if (length > 0) {
                    buffer.clear()
                    buffer.put(array, 0, length)
                    buffer.flip()

                    // Process ALL packets in this read
                    while (buffer.hasRemaining() && buffer.remaining() >= 20) {
                        val packetStart = buffer.position()
                        val ipHeaderLength = (buffer.get(packetStart).toInt() and 0x0F) * 4

                        if (ipHeaderLength < 20) {
                            buffer.position(buffer.limit())
                            break
                        }

                        val totalLength = ((buffer.get(packetStart + 2).toInt() and 0xFF) shl 8) or
                                (buffer.get(packetStart + 3).toInt() and 0xFF)

                        if (buffer.remaining() < totalLength) break

                        val packetData = ByteArray(totalLength)
                        buffer.get(packetData)

                        // Submit to fast pool for processing
                        fastPool.execute {
                            handlePacket(ByteBuffer.wrap(packetData))
                            stats.packetsProcessed.incrementAndGet()
                        }
                    }
                }
            }
        } catch (e: Exception) {
            DebugUtils.error("VPN Reader error", e)
        }
    }

    private fun handlePacket(packet: ByteBuffer) {
        if (packet.limit() < 20) return
        val version = (packet.get(0).toInt() shr 4) and 0x0F
        if (version != 4) return
        val protocol = packet.get(9).toInt() and 0xFF

        when (protocol) {
            6 -> handleTcpPacket(packet)
            17 -> handleUdpPacket(packet)
        }
    }

    private fun handleUdpPacket(packet: ByteBuffer) {
        try {
            val ipHeaderLen = (packet.get(0).toInt() and 0x0F) * 4
            val ipTotalLen = ((packet.get(2).toInt() and 0xFF) shl 8) or (packet.get(3).toInt() and 0xFF)
            if (packet.limit() < ipHeaderLen + 8) return

            val srcIp = parseIpAddress(packet, 12)
            val destIp = parseIpAddress(packet, 16)
            val srcPort = ((packet.get(ipHeaderLen).toInt() and 0xFF) shl 8) or (packet.get(ipHeaderLen + 1).toInt() and 0xFF)
            val destPort = ((packet.get(ipHeaderLen + 2).toInt() and 0xFF) shl 8) or (packet.get(ipHeaderLen + 3).toInt() and 0xFF)

            val payloadStart = ipHeaderLen + 8
            val payloadSize = ipTotalLen - ipHeaderLen - 8
            if (payloadSize <= 0) return

            val payload = ByteArray(payloadSize)
            packet.position(payloadStart)
            packet.get(payload)

            // OPTIMIZED: Direct UDP for DNS (faster than TCP)
            if (destPort == 53) {
                fastPool.execute { handleDnsDirectUdp(srcIp, srcPort, payload) }
                return
            }

            val connectionKey = "$srcIp:$srcPort-$destIp:$destPort"
            val relay = udpSockets.getOrPut(connectionKey) {
                UdpRelay(connectionKey, srcIp, srcPort, destIp, destPort)
            }
            relay.sendData(payload)
        } catch (e: Exception) {
            DebugUtils.error("UDP packet error", e)
        }
    }

    // ULTRA-OPTIMIZED: Direct UDP DNS (no SOCKS overhead)
    private fun handleDnsDirectUdp(srcIp: String, srcPort: Int, dnsPayload: ByteArray) {
        var socket: DatagramSocket? = null
        try {
            socket = DatagramSocket()
            if (!protect(socket)) return
            socket.soTimeout = 2000

            // Send directly to Google DNS
            val packet = DatagramPacket(dnsPayload, dnsPayload.size, InetAddress.getByName("8.8.8.8"), 53)
            socket.send(packet)

            // Receive response
            val responseBuffer = ByteArray(512)
            val responsePacket = DatagramPacket(responseBuffer, responseBuffer.size)
            socket.receive(responsePacket)

            val response = responseBuffer.copyOf(responsePacket.length)
            val udpResponse = buildUdpPacket("8.8.8.8", 53, srcIp, srcPort, response)
            writeToVpn(udpResponse)

            stats.dnsQueriesHandled.incrementAndGet()
        } catch (e: Exception) {
            DebugUtils.error("DNS Direct UDP error", e)
        } finally {
            socket?.close()
        }
    }

    inner class UdpRelay(
        private val key: String,
        private val srcIp: String,
        private val srcPort: Int,
        private val destIp: String,
        private val destPort: Int
    ) {
        private var socket: DatagramSocket? = null
        @Volatile var lastActivity = System.currentTimeMillis()
        private val running = AtomicBoolean(true)

        init {
            try {
                socket = DatagramSocket()
                socket?.receiveBufferSize = 524288 // 512KB
                socket?.sendBufferSize = 524288
                if (!this@MyVpnService.protect(socket!!)) throw Exception("Protect failed")
                socket?.soTimeout = 10000
                fastPool.execute { runReceiver() }
            } catch (e: Exception) {
                udpSockets.remove(key)
                close()
            }
        }

        fun sendData(payload: ByteArray) {
            try {
                val targetAddress = InetAddress.getByName(destIp)
                val packet = DatagramPacket(payload, payload.size, targetAddress, destPort)
                socket?.send(packet)
                lastActivity = System.currentTimeMillis()
            } catch (e: Exception) { }
        }

        private fun runReceiver() {
            val buffer = ByteArray(16384)
            val packet = DatagramPacket(buffer, buffer.size)
            try {
                while (running.get() && isRunning) {
                    try {
                        socket?.receive(packet)
                        val responsePayload = packet.data.copyOf(packet.length)
                        val response = buildUdpPacket(destIp, destPort, srcIp, srcPort, responsePayload)
                        writeToVpn(response)
                        lastActivity = System.currentTimeMillis()
                    } catch (e: SocketTimeoutException) {
                        // Normal timeout
                    } catch (e: Exception) {
                        break
                    }
                }
            } finally {
                udpSockets.remove(key)
                close()
            }
        }

        fun close() {
            running.set(false)
            try { socket?.close() } catch (e: Exception) {}
        }
    }

    private fun buildUdpPacket(srcIp: String, srcPort: Int, destIp: String, destPort: Int, payload: ByteArray): ByteArray {
        val totalLen = 28 + payload.size
        val packet = ByteArray(totalLen)
        packet[0] = 0x45; packet[1] = 0x00
        packet[2] = (totalLen shr 8).toByte(); packet[3] = totalLen.toByte()
        packet[6] = 0x40; packet[8] = 64; packet[9] = 17
        fillIpAddresses(packet, srcIp, destIp)
        val ipChecksum = calculateChecksum(packet, 0, 20)
        packet[10] = (ipChecksum shr 8).toByte(); packet[11] = ipChecksum.toByte()
        packet[20] = (srcPort shr 8).toByte(); packet[21] = srcPort.toByte()
        packet[22] = (destPort shr 8).toByte(); packet[23] = destPort.toByte()
        val udpLen = 8 + payload.size
        packet[24] = (udpLen shr 8).toByte(); packet[25] = udpLen.toByte()
        if (payload.isNotEmpty()) System.arraycopy(payload, 0, packet, 28, payload.size)
        return packet
    }

    private fun handleTcpPacket(packet: ByteBuffer) {
        try {
            val ipHeaderLen = (packet.get(0).toInt() and 0x0F) * 4
            val ipTotalLen = ((packet.get(2).toInt() and 0xFF) shl 8) or (packet.get(3).toInt() and 0xFF)
            if (packet.limit() < ipHeaderLen + 20) return

            val srcIp = parseIpAddress(packet, 12)
            val destIp = parseIpAddress(packet, 16)
            val srcPort = ((packet.get(ipHeaderLen).toInt() and 0xFF) shl 8) or (packet.get(ipHeaderLen + 1).toInt() and 0xFF)
            val destPort = ((packet.get(ipHeaderLen + 2).toInt() and 0xFF) shl 8) or (packet.get(ipHeaderLen + 3).toInt() and 0xFF)
            val tcpHeaderLen = ((packet.get(ipHeaderLen + 12).toInt() shr 4) and 0x0F) * 4
            val tcpFlags = packet.get(ipHeaderLen + 13).toInt() and 0xFF
            val seqNum = packet.getInt(ipHeaderLen + 4)
            val ackNum = packet.getInt(ipHeaderLen + 8)
            val connectionKey = "$srcIp:$srcPort-$destIp:$destPort"
            val payloadStart = ipHeaderLen + tcpHeaderLen
            val payloadSize = ipTotalLen - ipHeaderLen - tcpHeaderLen

            val flagSYN = (tcpFlags and 0x02) != 0
            val flagACK = (tcpFlags and 0x10) != 0
            val flagFIN = (tcpFlags and 0x01) != 0
            val flagRST = (tcpFlags and 0x04) != 0

            when {
                flagRST -> tcpConnections.remove(connectionKey)?.close()
                flagSYN && !flagACK -> {
                    if (tcpConnections.containsKey(connectionKey)) return
                    val connection = TcpConnection(connectionKey, srcIp, srcPort, destIp, destPort, proxyIp, proxyPort, seqNum, ackNum)
                    tcpConnections[connectionKey] = connection
                    fastPool.execute { connection.start() }
                    stats.tcpConnectionsCreated.incrementAndGet()
                }
                flagFIN -> tcpConnections[connectionKey]?.handleFIN(seqNum, ackNum)
                payloadSize > 0 -> {
                    val payload = ByteArray(payloadSize)
                    packet.position(payloadStart)
                    packet.get(payload)
                    val conn = tcpConnections[connectionKey]
                    if (conn != null) {
                        if (conn.isEstablished()) conn.sendData(payload, seqNum, ackNum)
                        else conn.queueData(payload, seqNum, ackNum)
                    }
                    stats.bytesTransferred.addAndGet(payloadSize.toLong())
                }
                flagACK -> tcpConnections[connectionKey]?.handleAck(ackNum)
            }
        } catch (e: Exception) {
            DebugUtils.error("TCP packet error", e)
        }
    }

    private fun cleanupStaleConnections() {
        while (isRunning) {
            try {
                Thread.sleep(5000) // Check every 5 seconds
                val now = System.currentTimeMillis()

                tcpConnections.values.removeIf {
                    if (now - it.lastActivity > 120000) { // 2 minutes
                        it.close()
                        true
                    } else false
                }

                udpSockets.values.removeIf {
                    if (now - it.lastActivity > 60000) { // 1 minute
                        it.close()
                        true
                    } else false
                }
            } catch (e: Exception) {}
        }
    }

    private fun printStats() {
        while (isRunning) {
            try {
                Thread.sleep(10000) // Every 10 seconds
                DebugUtils.log("""
                    === VPN STATS ===
                    TCP Connections: ${tcpConnections.size} (${stats.tcpConnectionsCreated.get()} created)
                    UDP Sockets: ${udpSockets.size}
                    Packets: Sent=${stats.packetsSent.get()}, Processed=${stats.packetsProcessed.get()}, Dropped=${stats.packetsDropped.get()}
                    DNS Queries: ${stats.dnsQueriesHandled.get()}
                    Bytes: ${stats.bytesTransferred.get() / 1024}KB
                    Queue: ${vpnWriteQueue.size}
                    Pool: Active=${fastPool.activeCount}, Queue=${fastPool.queue.size}
                """.trimIndent())
            } catch (e: Exception) {}
        }
    }

    private fun parseIpAddress(buffer: ByteBuffer, offset: Int): String {
        return "${buffer.get(offset).toInt() and 0xFF}.${buffer.get(offset + 1).toInt() and 0xFF}." +
                "${buffer.get(offset + 2).toInt() and 0xFF}.${buffer.get(offset + 3).toInt() and 0xFF}"
    }

    private fun fillIpAddresses(packet: ByteArray, srcIp: String, destIp: String) {
        val srcParts = srcIp.split(".")
        val destParts = destIp.split(".")
        for(i in 0..3) packet[12+i] = srcParts[i].toInt().toByte()
        for(i in 0..3) packet[16+i] = destParts[i].toInt().toByte()
    }

    private fun calculateChecksum(data: ByteArray, offset: Int, length: Int): Int {
        var sum = 0L
        var i = offset
        while (i < offset + length - 1) {
            val high = (data[i].toInt() and 0xFF) shl 8
            val low = (data[i + 1].toInt() and 0xFF)
            sum += (high or low)
            i += 2
        }
        if (i < offset + length) sum += (data[i].toInt() and 0xFF) shl 8
        while (sum shr 16 != 0L) sum = (sum and 0xFFFF) + (sum shr 16)
        return (sum.inv() and 0xFFFF).toInt()
    }

    data class PendingPacket(val payload: ByteArray, val seq: Int, val ack: Int)

    inner class TcpConnection(
        private val key: String,
        private val srcIp: String,
        private val srcPort: Int,
        private val destIp: String,
        private val destPort: Int,
        private val proxyIp: String,
        private val proxyPort: Int,
        initialLocalSeq: Int,
        initialRemoteSeq: Int
    ) {
        private var socket: Socket? = null
        private val established = AtomicBoolean(false)
        @Volatile var lastActivity = System.currentTimeMillis()
        private var localSeq = initialLocalSeq.toLong()
        private var remoteSeq = initialRemoteSeq.toLong()
        private val pendingData = ConcurrentLinkedQueue<PendingPacket>()

        fun isEstablished() = established.get()

        fun queueData(payload: ByteArray, seq: Int, ack: Int) {
            if (pendingData.size < 100) {
                pendingData.offer(PendingPacket(payload, seq, ack))
            }
        }

        fun start() {
            try {
                socket = Socket().apply {
                    tcpNoDelay = true
                    keepAlive = true
                    soTimeout = 60000
                    receiveBufferSize = 1048576 // 1MB for Instagram
                    sendBufferSize = 1048576
                }

                if (!this@MyVpnService.protect(socket!!)) throw Exception("Protect failed")
                socket?.connect(InetSocketAddress(proxyIp, proxyPort), 15000)

                val input = socket!!.getInputStream()
                val output = socket!!.getOutputStream()

                // SOCKS5 handshake
                output.write(byteArrayOf(0x05, 0x01, 0x00))
                output.flush()
                val handshake = ByteArray(2)
                if (input.read(handshake) < 2 || handshake[0] != 0x05.toByte()) {
                    throw Exception("Handshake failed")
                }

                // SOCKS5 connect
                val ipParts = destIp.split(".")
                val request = ByteArray(10)
                request[0] = 0x05; request[1] = 0x01; request[2] = 0x00; request[3] = 0x01
                for (i in 0..3) request[4 + i] = ipParts[i].toInt().toByte()
                request[8] = (destPort shr 8).toByte()
                request[9] = (destPort and 0xFF).toByte()
                output.write(request)
                output.flush()

                val response = ByteArray(10)
                if (input.read(response) < 10 || response[1] != 0x00.toByte()) {
                    throw Exception("Connect failed: ${response[1]}")
                }

                sendSynAck()
                established.set(true)

                // Send all pending data
                while (pendingData.isNotEmpty()) {
                    val pending = pendingData.poll()
                    if (pending != null) {
                        sendData(pending.payload, pending.seq, pending.ack)
                    }
                }

                fastPool.execute { runReceiver(input) }

            } catch (e: Exception) {
                DebugUtils.error("[$key] Connection failed", e)
                sendReset()
                tcpConnections.remove(key)
                close()
            }
        }

        private fun runReceiver(input: java.io.InputStream) {
            val buffer = ByteArray(32768) // 32KB buffer
            try {
                while (established.get() && isRunning) {
                    val len = input.read(buffer)
                    if (len <= 0) break
                    sendToVpn(buffer.copyOf(len))
                    lastActivity = System.currentTimeMillis()
                }
            } catch (e: Exception) {
                DebugUtils.error("[$key] Receiver error", e)
            } finally {
                tcpConnections.remove(key)
                close()
            }
        }

        fun sendData(payload: ByteArray, seqNum: Int, ackNum: Int) {
            if (!established.get()) return
            try {
                socket?.getOutputStream()?.write(payload)
                socket?.getOutputStream()?.flush()
                localSeq = seqNum.toLong() + payload.size
                val ack = buildTcpPacket(destIp, destPort, srcIp, srcPort, remoteSeq.toInt(), localSeq.toInt(), 0x10, byteArrayOf())
                writeToVpn(ack)
                lastActivity = System.currentTimeMillis()
            } catch (e: Exception) {
                close()
            }
        }

        private fun sendToVpn(payload: ByteArray) {
            val packet = buildTcpPacket(destIp, destPort, srcIp, srcPort, remoteSeq.toInt(), localSeq.toInt(), 0x18, payload)
            writeToVpn(packet)
            remoteSeq += payload.size
        }

        private fun sendSynAck() {
            val synAck = buildTcpPacket(destIp, destPort, srcIp, srcPort, remoteSeq.toInt(), (localSeq + 1).toInt(), 0x12, byteArrayOf())
            writeToVpn(synAck)
            remoteSeq++
            localSeq++
        }

        fun handleFIN(seqNum: Int, ackNum: Int) {
            localSeq = seqNum.toLong() + 1
            val finAck = buildTcpPacket(destIp, destPort, srcIp, srcPort, remoteSeq.toInt(), localSeq.toInt(), 0x11, byteArrayOf())
            writeToVpn(finAck)
            fastPool.execute {
                Thread.sleep(500)
                tcpConnections.remove(key)
                close()
            }
        }

        fun handleAck(ackNum: Int) {
            lastActivity = System.currentTimeMillis()
        }

        private fun sendReset() {
            val rst = buildTcpPacket(destIp, destPort, srcIp, srcPort, remoteSeq.toInt(), localSeq.toInt(), 0x04, byteArrayOf())
            writeToVpn(rst)
        }

        fun close() {
            established.set(false)
            try { socket?.close() } catch (e: Exception) {}
        }

        private fun buildTcpPacket(srcIp: String, srcPort: Int, destIp: String, destPort: Int, seqNum: Int, ackNum: Int, flags: Int, payload: ByteArray): ByteArray {
            val totalLen = 40 + payload.size
            val packet = ByteArray(totalLen)
            packet[0] = 0x45; packet[1] = 0x00
            packet[2] = (totalLen shr 8).toByte(); packet[3] = totalLen.toByte()
            packet[6] = 0x40; packet[8] = 64; packet[9] = 6
            fillIpAddresses(packet, srcIp, destIp)
            val ipChecksum = calculateChecksum(packet, 0, 20)
            packet[10] = (ipChecksum shr 8).toByte(); packet[11] = ipChecksum.toByte()
            packet[20] = (srcPort shr 8).toByte(); packet[21] = srcPort.toByte()
            packet[22] = (destPort shr 8).toByte(); packet[23] = destPort.toByte()
            packet[24] = (seqNum shr 24).toByte(); packet[25] = (seqNum shr 16).toByte()
            packet[26] = (seqNum shr 8).toByte(); packet[27] = seqNum.toByte()
            packet[28] = (ackNum shr 24).toByte(); packet[29] = (ackNum shr 16).toByte()
            packet[30] = (ackNum shr 8).toByte(); packet[31] = ackNum.toByte()
            packet[32] = 0x50; packet[33] = flags.toByte()
            packet[34] = 0xFF.toByte(); packet[35] = 0xFF.toByte()
            if (payload.isNotEmpty()) System.arraycopy(payload, 0, packet, 40, payload.size)
            val tcpChecksum = calculateTcpChecksum(packet, 20, 20 + payload.size, srcIp, destIp)
            packet[36] = (tcpChecksum shr 8).toByte(); packet[37] = tcpChecksum.toByte()
            return packet
        }

        private fun calculateTcpChecksum(packet: ByteArray, tcpOffset: Int, tcpLen: Int, srcIp: String, destIp: String): Int {
            val pseudoHeader = ByteArray(12 + tcpLen)
            val srcParts = srcIp.split(".")
            val destParts = destIp.split(".")
            for(i in 0..3) pseudoHeader[i] = srcParts[i].toInt().toByte()
            for(i in 0..3) pseudoHeader[4+i] = destParts[i].toInt().toByte()
            pseudoHeader[9] = 6
            pseudoHeader[10] = (tcpLen shr 8).toByte()
            pseudoHeader[11] = tcpLen.toByte()
            System.arraycopy(packet, tcpOffset, pseudoHeader, 12, tcpLen)
            return calculateChecksum(pseudoHeader, 0, pseudoHeader.size)
        }
    }

    private fun startForegroundNotification() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel("vpn_channel", "VPN Service", NotificationManager.IMPORTANCE_LOW)
            getSystemService(NotificationManager::class.java).createNotificationChannel(channel)
        }
        val notification = NotificationCompat.Builder(this, "vpn_channel")
            .setContentTitle("Instagram Optimized VPN")
            .setContentText("⚡ Ultra-fast mode active")
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .build()
        startForeground(1, notification)
    }

    private fun updateNotification(message: String) {
        val notification = NotificationCompat.Builder(this, "vpn_channel")
            .setContentTitle("VPN Service")
            .setContentText(message)
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .build()
        getSystemService(NotificationManager::class.java).notify(1, notification)
    }

    override fun onDestroy() {
        isRunning = false
        fastPool.shutdownNow()
        readerPool.shutdownNow()
        tcpConnections.values.forEach { it.close() }
        tcpConnections.clear()
        udpSockets.values.forEach { it.close() }
        udpSockets.clear()
        vpnWriter?.close()
        vpnInterface?.close()
        super.onDestroy()
    }

    // Statistics tracking
    class Stats {
        val packetsSent = AtomicInteger(0)
        val packetsProcessed = AtomicInteger(0)
        val packetsDropped = AtomicInteger(0)
        val tcpConnectionsCreated = AtomicInteger(0)
        val dnsQueriesHandled = AtomicInteger(0)
        val bytesTransferred = AtomicLong(0L) // Changed from AtomicInteger to AtomicLong
    }
}

============================================================
FILE: app\src\main\java\com\example\hotspot_bypass_vpn\Myvpnserviceoptimized.kt
============================================================

package com.example.hotspot_bypass_vpn

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Intent
import android.net.VpnService
import android.os.Build
import android.os.ParcelFileDescriptor
import androidx.core.app.NotificationCompat
import java.io.FileInputStream
import java.io.FileOutputStream
import java.net.DatagramPacket
import java.net.DatagramSocket
import java.net.InetSocketAddress
import java.net.InetAddress
import java.net.Socket
import java.nio.ByteBuffer
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.LinkedBlockingQueue
import java.util.concurrent.ThreadPoolExecutor
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicBoolean
import kotlin.concurrent.thread

class MyVpnServiceOptimized : VpnService() {

    private var vpnInterface: ParcelFileDescriptor? = null
    private var isRunning = false
    private var proxyIp = ""
    private var proxyPort = 0

    private val tcpConnections = ConcurrentHashMap<String, TcpConnection>()
    private val udpSockets = ConcurrentHashMap<String, UdpRelay>()

    // **OPTIMIZATION 1: DNS Cache**
    private val dnsCache = DnsCache()

    // **OPTIMIZATION 2: Reuse DNS connections**
    private val dnsConnectionPool = ConcurrentHashMap<String, Socket>()

    private val connectionPool = ThreadPoolExecutor(
        20, 500, 60L, TimeUnit.SECONDS,
        LinkedBlockingQueue(5000), ThreadPoolExecutor.CallerRunsPolicy()
    )

    private val vpnWriteQueue = LinkedBlockingQueue<ByteArray>(10000)
    private var vpnWriter: FileOutputStream? = null

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        proxyIp = intent?.getStringExtra("PROXY_IP") ?: "192.168.49.1"
        proxyPort = intent?.getIntExtra("PROXY_PORT", 8080) ?: 8080

        startForegroundNotification()

        thread(name = "ProxyTest") {
            if (DebugUtils.testProxyConnection(proxyIp, proxyPort)) {
                startVpnInterface()
            } else {
                updateNotification("Error: Cannot reach Phone A")
                stopSelf()
            }
        }
        return START_STICKY
    }

    private fun startVpnInterface() {
        val builder = Builder()
            .setMtu(1500)
            .addAddress("10.0.0.2", 32)
            .addRoute("0.0.0.0", 0)
            .addDisallowedApplication(packageName)
            .addDnsServer("8.8.8.8")
            .addDnsServer("8.8.4.4")
            .setBlocking(false)

        vpnInterface = builder.establish()

        if (vpnInterface != null) {
            isRunning = true
            updateNotification("VPN Active - Optimized")
            thread(name = "VPN-Writer", isDaemon = true) { runVpnWriterOptimized() }
            thread(name = "VPN-Reader", isDaemon = true) { readPacketsOptimized() }
            thread(name = "Cleanup", isDaemon = true) { cleanupStaleConnections() }
        }
    }

    private fun runVpnWriterOptimized() {
        vpnWriter = FileOutputStream(vpnInterface!!.fileDescriptor)
        val batch = ArrayList<ByteArray>(100)
        try {
            while (isRunning) {
                batch.clear()
                val first = vpnWriteQueue.poll(10, TimeUnit.MILLISECONDS)
                if (first != null) {
                    batch.add(first)
                    vpnWriteQueue.drainTo(batch, 99)

                    for (packet in batch) {
                        vpnWriter?.write(packet)
                    }
                    vpnWriter?.flush()
                }
            }
        } catch (e: Exception) {
            DebugUtils.error("VPN Writer error", e)
        }
    }

    private fun writeToVpn(packet: ByteArray) {
        if (!vpnWriteQueue.offer(packet)) {
            vpnWriteQueue.poll()
            vpnWriteQueue.offer(packet)
        }
    }

    private fun readPacketsOptimized() {
        val inputStream = FileInputStream(vpnInterface!!.fileDescriptor)
        val buffer = ByteBuffer.allocateDirect(65536)
        val array = ByteArray(65536)

        try {
            while (isRunning) {
                val length = inputStream.read(array)
                if (length > 0) {
                    buffer.clear()
                    buffer.put(array, 0, length)
                    buffer.flip()

                    while (buffer.hasRemaining() && buffer.remaining() >= 20) {
                        val packetStart = buffer.position()
                        val ipHeaderLength = (buffer.get(packetStart).toInt() and 0x0F) * 4
                        val totalLength = ((buffer.get(packetStart + 2).toInt() and 0xFF) shl 8) or
                                (buffer.get(packetStart + 3).toInt() and 0xFF)

                        if (buffer.remaining() < totalLength) break

                        val packetData = ByteArray(totalLength)
                        buffer.get(packetData)

                        val packet = ByteBuffer.wrap(packetData)
                        connectionPool.execute { handlePacket(packet) }
                    }

                    buffer.clear()
                }
            }
        } catch (e: Exception) {
            DebugUtils.error("VPN Reader error", e)
        }
    }

    private fun handlePacket(packet: ByteBuffer) {
        if (packet.limit() < 20) return
        val version = (packet.get(0).toInt() shr 4) and 0x0F
        if (version != 4) return
        val protocol = packet.get(9).toInt() and 0xFF

        when (protocol) {
            6 -> handleTcpPacket(packet)
            17 -> handleUdpPacket(packet)
        }
    }

    private fun handleUdpPacket(packet: ByteBuffer) {
        try {
            val ipHeaderLen = (packet.get(0).toInt() and 0x0F) * 4
            val ipTotalLen = ((packet.get(2).toInt() and 0xFF) shl 8) or (packet.get(3).toInt() and 0xFF)
            if (packet.limit() < ipHeaderLen + 8) return

            val srcIp = parseIpAddress(packet, 12)
            val destIp = parseIpAddress(packet, 16)
            val srcPort = ((packet.get(ipHeaderLen).toInt() and 0xFF) shl 8) or (packet.get(ipHeaderLen + 1).toInt() and 0xFF)
            val destPort = ((packet.get(ipHeaderLen + 2).toInt() and 0xFF) shl 8) or (packet.get(ipHeaderLen + 3).toInt() and 0xFF)

            val payloadStart = ipHeaderLen + 8
            val payloadSize = ipTotalLen - ipHeaderLen - 8
            if (payloadSize <= 0) return

            val payload = ByteArray(payloadSize)
            packet.position(payloadStart)
            packet.get(payload)

            if (destPort == 53) {
                // **OPTIMIZATION 3: Fast DNS handling with cache**
                handleDnsOptimized(srcIp, srcPort, destIp, destPort, payload)
                return
            }

            val connectionKey = "$srcIp:$srcPort-$destIp:$destPort"
            val relay = udpSockets.getOrPut(connectionKey) { UdpRelay(connectionKey, srcIp, srcPort, destIp, destPort) }
            relay.sendData(payload)
        } catch (e: Exception) { }
    }

    // **OPTIMIZATION 4: Dramatically faster DNS with caching**
    private fun handleDnsOptimized(srcIp: String, srcPort: Int, destIp: String, destPort: Int, dnsPayload: ByteArray) {
        // Try to extract domain name from DNS query to check cache
        val domain = extractDomainFromDnsQuery(dnsPayload)

        if (domain != null) {
            val cachedIp = dnsCache.get(domain)
            if (cachedIp != null) {
                // Cache hit! Return immediately without network call
                DebugUtils.log("DNS Cache HIT: $domain")
                val response = buildDnsResponse(dnsPayload, cachedIp)
                val udpResponse = buildUdpPacket(destIp, destPort, srcIp, srcPort, response)
                writeToVpn(udpResponse)
                return
            }
            DebugUtils.log("DNS Cache MISS: $domain")
        }

        // Cache miss or couldn't parse - do actual DNS lookup
        // Use connection pool instead of creating new thread each time
        connectionPool.execute {
            var dnsSocket: Socket? = null
            try {
                dnsSocket = Socket()
                if (!protect(dnsSocket)) return@execute
                dnsSocket.soTimeout = 2000 // Reduced timeout
                dnsSocket.connect(InetSocketAddress(proxyIp, proxyPort), 2000)
                val out = dnsSocket.getOutputStream()
                val ins = dnsSocket.getInputStream()

                out.write(byteArrayOf(0x05, 0x01, 0x00))
                ins.read(ByteArray(2))

                val request = byteArrayOf(0x05, 0x01, 0x00, 0x01, 8, 8, 8, 8, 0x00, 0x35)
                out.write(request)
                ins.read(ByteArray(10))

                val len = dnsPayload.size
                out.write(byteArrayOf((len shr 8).toByte(), (len and 0xFF).toByte()))
                out.write(dnsPayload)
                out.flush()

                val b1 = ins.read(); val b2 = ins.read()
                if (b1 != -1 && b2 != -1) {
                    val respLen = ((b1 and 0xFF) shl 8) or (b2 and 0xFF)
                    val respBody = ByteArray(respLen)
                    var totalRead = 0
                    while (totalRead < respLen) {
                        val r = ins.read(respBody, totalRead, respLen - totalRead)
                        if (r == -1) break
                        totalRead += r
                    }

                    // **Cache the result for next time**
                    if (domain != null) {
                        val ipAddress = extractIpFromDnsResponse(respBody)
                        if (ipAddress != null) {
                            dnsCache.put(domain, ipAddress)
                            DebugUtils.log("DNS Cached: $domain -> ${ipAddress.joinToString(".")}")
                        }
                    }

                    val udpResponse = buildUdpPacket(destIp, destPort, srcIp, srcPort, respBody)
                    writeToVpn(udpResponse)
                }
            } catch (e: Exception) {
                DebugUtils.error("DNS lookup failed", e)
            } finally {
                try { dnsSocket?.close() } catch (e: Exception) {}
            }
        }
    }

    // Extract domain name from DNS query packet
    private fun extractDomainFromDnsQuery(dnsPayload: ByteArray): String? {
        try {
            if (dnsPayload.size < 13) return null

            var pos = 12 // Skip header
            val parts = mutableListOf<String>()

            while (pos < dnsPayload.size) {
                val len = dnsPayload[pos].toInt() and 0xFF
                if (len == 0) break
                if (len > 63 || pos + len >= dnsPayload.size) return null

                val part = String(dnsPayload, pos + 1, len, Charsets.UTF_8)
                parts.add(part)
                pos += len + 1
            }

            return if (parts.isEmpty()) null else parts.joinToString(".")
        } catch (e: Exception) {
            return null
        }
    }

    // Extract IP address from DNS response
    private fun extractIpFromDnsResponse(response: ByteArray): ByteArray? {
        try {
            // Simple A record extraction (IPv4)
            // This is a simplified parser - real DNS responses are complex
            var pos = 12

            // Skip question section
            while (pos < response.size && response[pos].toInt() != 0) {
                pos++
            }
            pos += 5 // Skip null terminator + QTYPE + QCLASS

            // Look for answer with type A (0x0001)
            while (pos + 12 < response.size) {
                // Check if this is a pointer (compression)
                if ((response[pos].toInt() and 0xC0) == 0xC0) {
                    pos += 2 // Skip pointer
                } else {
                    // Skip name
                    while (pos < response.size && response[pos].toInt() != 0) pos++
                    pos++
                }

                if (pos + 10 > response.size) break

                val type = ((response[pos].toInt() and 0xFF) shl 8) or (response[pos + 1].toInt() and 0xFF)
                val dataLen = ((response[pos + 8].toInt() and 0xFF) shl 8) or (response[pos + 9].toInt() and 0xFF)

                if (type == 1 && dataLen == 4) { // A record
                    return byteArrayOf(
                        response[pos + 10],
                        response[pos + 11],
                        response[pos + 12],
                        response[pos + 13]
                    )
                }

                pos += 10 + dataLen
            }
        } catch (e: Exception) {
        }
        return null
    }

    // Build DNS response from cached IP
    private fun buildDnsResponse(query: ByteArray, ipAddress: ByteArray): ByteArray {
        // Simple DNS response builder
        val response = ByteArray(query.size + 16)

        // Copy query as base
        System.arraycopy(query, 0, response, 0, query.size)

        // Set flags: response + authoritative
        response[2] = 0x81.toByte()
        response[3] = 0x80.toByte()

        // Answer count = 1
        response[6] = 0x00
        response[7] = 0x01

        // Add answer section at end
        var pos = query.size
        response[pos++] = 0xC0.toByte() // Pointer to question name
        response[pos++] = 0x0C.toByte()
        response[pos++] = 0x00 // Type A
        response[pos++] = 0x01
        response[pos++] = 0x00 // Class IN
        response[pos++] = 0x01
        response[pos++] = 0x00 // TTL (1 hour)
        response[pos++] = 0x00
        response[pos++] = 0x00
        response[pos++] = 0xE1.toByte()
        response[pos++] = 0x00 // Data length
        response[pos++] = 0x04
        // IP address
        System.arraycopy(ipAddress, 0, response, pos, 4)

        return response.copyOf(pos + 4)
    }

    // ... Rest of the class remains the same (UDP relay, TCP connection, helper methods) ...
    // I'll include the critical parts below:

    inner class UdpRelay(private val key: String, private val srcIp: String, private val srcPort: Int, private val destIp: String, private val destPort: Int) {
        private var socket: DatagramSocket? = null
        @Volatile var lastActivity = System.currentTimeMillis()
        private val running = AtomicBoolean(true)

        init {
            try {
                socket = DatagramSocket()
                socket?.receiveBufferSize = 262144
                socket?.sendBufferSize = 262144
                if (!this@MyVpnServiceOptimized.protect(socket!!)) throw Exception("Protect failed")
                socket?.soTimeout = 5000
                connectionPool.execute { runReceiver() }
            } catch (e: Exception) { udpSockets.remove(key); close() }
        }

        fun sendData(payload: ByteArray) {
            try {
                val targetAddress = InetAddress.getByName(destIp)
                val packet = DatagramPacket(payload, payload.size, targetAddress, destPort)
                socket?.send(packet)
                lastActivity = System.currentTimeMillis()
            } catch (e: Exception) { }
        }

        private fun runReceiver() {
            val buffer = ByteArray(8192)
            val packet = DatagramPacket(buffer, buffer.size)
            try {
                while (running.get() && isRunning) {
                    try {
                        socket?.receive(packet)
                        val responsePayload = packet.data.copyOf(packet.length)
                        val response = buildUdpPacket(destIp, destPort, srcIp, srcPort, responsePayload)
                        writeToVpn(response)
                        lastActivity = System.currentTimeMillis()
                    } catch (e: java.net.SocketTimeoutException) { } catch (e: Exception) { break }
                }
            } finally { udpSockets.remove(key); close() }
        }

        fun close() { running.set(false); try { socket?.close() } catch (e: Exception) {} }
    }

    private fun buildUdpPacket(srcIp: String, srcPort: Int, destIp: String, destPort: Int, payload: ByteArray): ByteArray {
        val totalLen = 28 + payload.size
        val packet = ByteArray(totalLen)
        packet[0] = 0x45; packet[1] = 0x00; packet[2] = (totalLen shr 8).toByte(); packet[3] = totalLen.toByte()
        packet[6] = 0x40; packet[8] = 64; packet[9] = 17
        fillIpAddresses(packet, srcIp, destIp)
        val ipChecksum = calculateChecksum(packet, 0, 20)
        packet[10] = (ipChecksum shr 8).toByte(); packet[11] = ipChecksum.toByte()
        packet[20] = (srcPort shr 8).toByte(); packet[21] = srcPort.toByte()
        packet[22] = (destPort shr 8).toByte(); packet[23] = destPort.toByte()
        val udpLen = 8 + payload.size
        packet[24] = (udpLen shr 8).toByte(); packet[25] = udpLen.toByte()
        if (payload.isNotEmpty()) System.arraycopy(payload, 0, packet, 28, payload.size)
        return packet
    }

    // Continue with TCP handling and other methods from original...
    // (Include handleTcpPacket, TcpConnection class, cleanup methods, etc.)

    private fun handleTcpPacket(packet: ByteBuffer) {
        // Same as original implementation
        try {
            val ipHeaderLen = (packet.get(0).toInt() and 0x0F) * 4
            val ipTotalLen = ((packet.get(2).toInt() and 0xFF) shl 8) or (packet.get(3).toInt() and 0xFF)
            if (packet.limit() < ipHeaderLen + 20) return

            val srcIp = parseIpAddress(packet, 12)
            val destIp = parseIpAddress(packet, 16)
            val srcPort = ((packet.get(ipHeaderLen).toInt() and 0xFF) shl 8) or (packet.get(ipHeaderLen + 1).toInt() and 0xFF)
            val destPort = ((packet.get(ipHeaderLen + 2).toInt() and 0xFF) shl 8) or (packet.get(ipHeaderLen + 3).toInt() and 0xFF)
            val tcpHeaderLen = ((packet.get(ipHeaderLen + 12).toInt() shr 4) and 0x0F) * 4
            val tcpFlags = packet.get(ipHeaderLen + 13).toInt() and 0xFF
            val seqNum = packet.getInt(ipHeaderLen + 4)
            val ackNum = packet.getInt(ipHeaderLen + 8)
            val connectionKey = "$srcIp:$srcPort-$destIp:$destPort"
            val payloadStart = ipHeaderLen + tcpHeaderLen
            val payloadSize = ipTotalLen - ipHeaderLen - tcpHeaderLen

            val flagSYN = (tcpFlags and 0x02) != 0
            val flagACK = (tcpFlags and 0x10) != 0
            val flagFIN = (tcpFlags and 0x01) != 0
            val flagRST = (tcpFlags and 0x04) != 0

            when {
                flagRST -> tcpConnections.remove(connectionKey)?.close()
                flagSYN && !flagACK -> {
                    if (tcpConnections.containsKey(connectionKey)) return
                    val connection = TcpConnection(connectionKey, srcIp, srcPort, destIp, destPort, proxyIp, proxyPort, seqNum, ackNum)
                    tcpConnections[connectionKey] = connection
                    connectionPool.execute { connection.start() }
                }
                flagFIN -> tcpConnections[connectionKey]?.handleFIN(seqNum, ackNum)
                payloadSize > 0 -> {
                    val payload = ByteArray(payloadSize)
                    packet.position(payloadStart)
                    packet.get(payload)
                    val conn = tcpConnections[connectionKey]
                    if (conn != null) {
                        if (conn.isEstablished()) conn.sendData(payload, seqNum, ackNum)
                        else conn.queueData(payload, seqNum, ackNum)
                    }
                }
                flagACK -> tcpConnections[connectionKey]?.handleAck(ackNum)
            }
        } catch (e: Exception) { }
    }

    private fun cleanupStaleConnections() {
        while (isRunning) {
            try {
                Thread.sleep(10000)
                val now = System.currentTimeMillis()
                tcpConnections.values.removeIf { if (now - it.lastActivity > 60000) { it.close(); true } else false }
                udpSockets.values.removeIf { if (now - it.lastActivity > 30000) { it.close(); true } else false }
            } catch (e: Exception) {}
        }
    }

    private fun parseIpAddress(buffer: ByteBuffer, offset: Int): String {
        return "${buffer.get(offset).toInt() and 0xFF}.${buffer.get(offset + 1).toInt() and 0xFF}.${buffer.get(offset + 2).toInt() and 0xFF}.${buffer.get(offset + 3).toInt() and 0xFF}"
    }

    private fun fillIpAddresses(packet: ByteArray, srcIp: String, destIp: String) {
        val srcParts = srcIp.split("."); val destParts = destIp.split(".")
        for(i in 0..3) packet[12+i] = srcParts[i].toInt().toByte()
        for(i in 0..3) packet[16+i] = destParts[i].toInt().toByte()
    }

    private fun calculateChecksum(data: ByteArray, offset: Int, length: Int): Int {
        var sum = 0L; var i = offset
        while (i < offset + length - 1) {
            val high = (data[i].toInt() and 0xFF) shl 8
            val low = (data[i + 1].toInt() and 0xFF)
            sum += (high or low)
            i += 2
        }
        if (i < offset + length) sum += (data[i].toInt() and 0xFF) shl 8
        while (sum shr 16 != 0L) sum = (sum and 0xFFFF) + (sum shr 16)
        return (sum.inv() and 0xFFFF).toInt()
    }

    data class PendingPacket(val payload: ByteArray, val seq: Int, val ack: Int)

    inner class TcpConnection(
        private val key: String, private val srcIp: String, private val srcPort: Int, private val destIp: String, private val destPort: Int,
        private val proxyIp: String, private val proxyPort: Int, initialLocalSeq: Int, initialRemoteSeq: Int
    ) {
        private var socket: Socket? = null
        private val established = AtomicBoolean(false)
        @Volatile var lastActivity = System.currentTimeMillis()
        private var localSeq = initialLocalSeq.toLong()
        private var remoteSeq = initialRemoteSeq.toLong()
        private val pendingData = ArrayList<PendingPacket>()

        fun isEstablished() = established.get()
        fun queueData(payload: ByteArray, seq: Int, ack: Int) {
            synchronized(pendingData) {
                if (pendingData.size < 50) pendingData.add(PendingPacket(payload, seq, ack))
            }
        }

        fun start() {
            try {
                socket = Socket().apply {
                    tcpNoDelay = true
                    keepAlive = true
                    soTimeout = 30000
                    receiveBufferSize = 524288
                    sendBufferSize = 524288
                }
                if (!this@MyVpnServiceOptimized.protect(socket!!)) throw Exception("Protect failed")
                socket?.connect(InetSocketAddress(proxyIp, proxyPort), 10000)
                val input = socket!!.getInputStream(); val output = socket!!.getOutputStream()

                output.write(byteArrayOf(0x05, 0x01, 0x00)); output.flush()
                val handshake = ByteArray(2); if (input.read(handshake) < 2 || handshake[0] != 0x05.toByte()) throw Exception("Handshake failed")

                val ipParts = destIp.split(".")
                val request = ByteArray(10)
                request[0] = 0x05; request[1] = 0x01; request[2] = 0x00; request[3] = 0x01
                for (i in 0..3) request[4 + i] = ipParts[i].toInt().toByte()
                request[8] = (destPort shr 8).toByte(); request[9] = (destPort and 0xFF).toByte()
                output.write(request); output.flush()

                val response = ByteArray(10); if (input.read(response) < 10 || response[1] != 0x00.toByte()) throw Exception("Connect failed")

                sendSynAck()
                established.set(true)
                synchronized(pendingData) { for (pending in pendingData) sendData(pending.payload, pending.seq, pending.ack); pendingData.clear() }
                connectionPool.execute { runReceiver(input) }
            } catch (e: Exception) { sendReset(); tcpConnections.remove(key); close() }
        }

        private fun runReceiver(input: java.io.InputStream) {
            val buffer = ByteArray(8192)
            try {
                while (established.get() && isRunning) {
                    val len = input.read(buffer)
                    if (len <= 0) break
                    sendToVpn(buffer.copyOf(len))
                    lastActivity = System.currentTimeMillis()
                }
            } catch (e: Exception) { } finally { tcpConnections.remove(key); close() }
        }

        fun sendData(payload: ByteArray, seqNum: Int, ackNum: Int) {
            if (!established.get()) return
            try {
                socket?.getOutputStream()?.write(payload)
                socket?.getOutputStream()?.flush()
                localSeq = seqNum.toLong() + payload.size
                val ack = buildTcpPacket(destIp, destPort, srcIp, srcPort, remoteSeq.toInt(), localSeq.toInt(), 0x10, byteArrayOf())
                writeToVpn(ack)
                lastActivity = System.currentTimeMillis()
            } catch (e: Exception) { close() }
        }

        private fun sendToVpn(payload: ByteArray) {
            val packet = buildTcpPacket(destIp, destPort, srcIp, srcPort, remoteSeq.toInt(), localSeq.toInt(), 0x18, payload)
            writeToVpn(packet)
            remoteSeq += payload.size
        }

        private fun sendSynAck() {
            val synAck = buildTcpPacket(destIp, destPort, srcIp, srcPort, remoteSeq.toInt(), (localSeq + 1).toInt(), 0x12, byteArrayOf())
            writeToVpn(synAck)
            remoteSeq++; localSeq++
        }

        fun handleFIN(seqNum: Int, ackNum: Int) {
            localSeq = seqNum.toLong() + 1
            val finAck = buildTcpPacket(destIp, destPort, srcIp, srcPort, remoteSeq.toInt(), localSeq.toInt(), 0x11, byteArrayOf())
            writeToVpn(finAck)
            connectionPool.execute { Thread.sleep(500); tcpConnections.remove(key); close() }
        }

        fun handleAck(ackNum: Int) { lastActivity = System.currentTimeMillis() }

        private fun sendReset() {
            val rst = buildTcpPacket(destIp, destPort, srcIp, srcPort, remoteSeq.toInt(), localSeq.toInt(), 0x04, byteArrayOf())
            writeToVpn(rst)
        }

        fun close() { established.set(false); try { socket?.close() } catch (e: Exception) {} }

        private fun buildTcpPacket(srcIp: String, srcPort: Int, destIp: String, destPort: Int, seqNum: Int, ackNum: Int, flags: Int, payload: ByteArray): ByteArray {
            val totalLen = 40 + payload.size
            val packet = ByteArray(totalLen)
            packet[0] = 0x45; packet[1] = 0x00; packet[2] = (totalLen shr 8).toByte(); packet[3] = totalLen.toByte()
            packet[6] = 0x40; packet[8] = 64; packet[9] = 6
            fillIpAddresses(packet, srcIp, destIp)
            val ipChecksum = calculateChecksum(packet, 0, 20)
            packet[10] = (ipChecksum shr 8).toByte(); packet[11] = ipChecksum.toByte()
            packet[20] = (srcPort shr 8).toByte(); packet[21] = srcPort.toByte()
            packet[22] = (destPort shr 8).toByte(); packet[23] = destPort.toByte()
            packet[24] = (seqNum shr 24).toByte(); packet[25] = (seqNum shr 16).toByte(); packet[26] = (seqNum shr 8).toByte(); packet[27] = seqNum.toByte()
            packet[28] = (ackNum shr 24).toByte(); packet[29] = (ackNum shr 16).toByte(); packet[30] = (ackNum shr 8).toByte(); packet[31] = ackNum.toByte()
            packet[32] = 0x50; packet[33] = flags.toByte();
            packet[34] = 0xFF.toByte(); packet[35] = 0xFF.toByte()
            if (payload.isNotEmpty()) System.arraycopy(payload, 0, packet, 40, payload.size)
            val tcpChecksum = calculateTcpChecksum(packet, 20, 20 + payload.size, srcIp, destIp)
            packet[36] = (tcpChecksum shr 8).toByte(); packet[37] = tcpChecksum.toByte()
            return packet
        }

        private fun calculateTcpChecksum(packet: ByteArray, tcpOffset: Int, tcpLen: Int, srcIp: String, destIp: String): Int {
            val pseudoHeader = ByteArray(12 + tcpLen)
            val srcParts = srcIp.split("."); val destParts = destIp.split(".")
            for(i in 0..3) pseudoHeader[i] = srcParts[i].toInt().toByte()
            for(i in 0..3) pseudoHeader[4+i] = destParts[i].toInt().toByte()
            pseudoHeader[9] = 6; pseudoHeader[10] = (tcpLen shr 8).toByte(); pseudoHeader[11] = tcpLen.toByte()
            System.arraycopy(packet, tcpOffset, pseudoHeader, 12, tcpLen)
            return calculateChecksum(pseudoHeader, 0, pseudoHeader.size)
        }
    }

    private fun startForegroundNotification() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel("vpn_channel", "VPN Service", NotificationManager.IMPORTANCE_LOW)
            getSystemService(NotificationManager::class.java).createNotificationChannel(channel)
        }
        val notification = NotificationCompat.Builder(this, "vpn_channel")
            .setContentTitle("VPN Running")
            .setContentText("DNS Cache: ${dnsCache.size()} entries")
            .setSmallIcon(android.R.drawable.ic_dialog_info).build()
        startForeground(1, notification)
    }

    private fun updateNotification(message: String) {
        val notification = NotificationCompat.Builder(this, "vpn_channel")
            .setContentTitle("VPN Service")
            .setContentText("$message | DNS: ${dnsCache.size()}")
            .setSmallIcon(android.R.drawable.ic_dialog_info).build()
        getSystemService(NotificationManager::class.java).notify(1, notification)
    }

    override fun onDestroy() {
        isRunning = false; connectionPool.shutdownNow()
        tcpConnections.values.forEach { it.close() }; tcpConnections.clear()
        udpSockets.values.forEach { it.close() }; udpSockets.clear()
        dnsCache.clear()
        vpnWriter?.close(); vpnInterface?.close()
        super.onDestroy()
    }
}

============================================================
FILE: app\src\main\java\com\example\hotspot_bypass_vpn\Myvpnservicetun2socks.kt
============================================================

package com.example.hotspot_bypass_vpn

import android.app.NotificationChannel
import android.app.NotificationManager
import android.content.Intent
import android.net.VpnService
import android.os.Build
import android.os.ParcelFileDescriptor
import androidx.core.app.NotificationCompat
import engine.Engine
import kotlin.concurrent.thread

class MyVpnServiceTun2Socks : VpnService() {

    private var vpnInterface: ParcelFileDescriptor? = null
    private var isRunning = false
    private var proxyIp = ""
    private var proxyPort = 0

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        proxyIp = intent?.getStringExtra("PROXY_IP") ?: "192.168.49.1"
        proxyPort = intent?.getIntExtra("PROXY_PORT", 8080) ?: 8080

        startForegroundNotification()

        thread(name = "ProxyTest") {
            if (DebugUtils.testProxyConnection(proxyIp, proxyPort)) {
                startVpnWithTun2Socks()
            } else {
                updateNotification("Error: Cannot reach proxy at $proxyIp:$proxyPort")
                stopSelf()
            }
        }

        return START_STICKY
    }

    private fun startVpnWithTun2Socks() {
        try {
            DebugUtils.log("Setting up VPN interface...")

            val builder = Builder()
                .setMtu(1500)
                .addAddress("10.0.0.2", 24)
                .addRoute("0.0.0.0", 0)
                .addDisallowedApplication(packageName)
                .addDnsServer("8.8.8.8")
                .addDnsServer("8.8.4.4")
                .setSession("Hotspot Bypass VPN")
                .setBlocking(true)

            vpnInterface = builder.establish()

            if (vpnInterface == null) {
                DebugUtils.error("Failed to establish VPN interface")
                updateNotification("Error: VPN interface creation failed")
                stopSelf()
                return
            }

            val fd = vpnInterface!!.fd
            DebugUtils.log("VPN interface established with fd: $fd")

            isRunning = true
            updateNotification("VPN Active - Routing through tun2socks")

            // Start tun2socks in a separate thread
            thread(name = "tun2socks-engine", isDaemon = false) {
                runTun2Socks(fd)
            }

        } catch (e: Exception) {
            DebugUtils.error("Failed to start VPN", e)
            updateNotification("Error: ${e.message}")
            stopSelf()
        }
    }

    private fun runTun2Socks(fd: Int) {
        try {
            val socksProxy = "socks5://$proxyIp:$proxyPort"

            DebugUtils.log("Configuring tun2socks engine...")

            // 1. Create a Key object for configuration
            val key = engine.Key()

            // 2. Set the parameters using the Key object
            // Note: The device must be "fd://<number>" for Android
            key.setDevice("fd://$fd")
            key.setProxy(socksProxy)
            key.setMTU(1500L)
            key.setLogLevel("info")

            // Optional: Some versions allow setting DNS here,
            // but often it's handled by the VPN Builder routes
            // key.setDNS("8.8.8.8,8.8.4.4")

            // 3. Register the configuration and start the engine
            Engine.insert(key)
            Engine.start()

            DebugUtils.log("✓ tun2socks started successfully!")
            updateNotification("✓ VPN Active - Connected to $proxyIp:$proxyPort")

            // Keep the thread alive while VPN is running
            while (isRunning) {
                Thread.sleep(1000)
            }

        } catch (e: Exception) {
            DebugUtils.error("tun2socks error", e)
            updateNotification("Error: ${e.message}")
        } finally {
            DebugUtils.log("tun2socks engine stopped")
        }
    }

    private fun startForegroundNotification() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val channel = NotificationChannel(
                "vpn_channel",
                "VPN Service",
                NotificationManager.IMPORTANCE_LOW
            )
            getSystemService(NotificationManager::class.java).createNotificationChannel(channel)
        }

        val notification = NotificationCompat.Builder(this, "vpn_channel")
            .setContentTitle("Hotspot Bypass VPN")
            .setContentText("Initializing tun2socks...")
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .build()

        startForeground(1, notification)
    }

    private fun updateNotification(message: String) {
        val notification = NotificationCompat.Builder(this, "vpn_channel")
            .setContentTitle("Hotspot Bypass VPN")
            .setContentText(message)
            .setSmallIcon(android.R.drawable.ic_dialog_info)
            .setPriority(NotificationCompat.PRIORITY_LOW)
            .build()

        getSystemService(NotificationManager::class.java).notify(1, notification)
    }

    override fun onDestroy() {
        DebugUtils.log("Stopping VPN service...")
        isRunning = false

        try {
            DebugUtils.log("Stopping tun2socks engine...")
            Engine.stop() // Change Tun2socks.stop to Engine.stop
            DebugUtils.log("✓ tun2socks stopped")
        } catch (e: Exception) {
            DebugUtils.error("Error stopping tun2socks", e)
        }

        try {
            vpnInterface?.close()
            vpnInterface = null
            DebugUtils.log("✓ VPN interface closed")
        } catch (e: Exception) {
            DebugUtils.error("Error closing VPN interface", e)
        }

        super.onDestroy()
    }

    override fun onRevoke() {
        DebugUtils.log("VPN permission revoked by user")
        stopSelf()
        super.onRevoke()
    }
}

============================================================
FILE: app\src\main\java\com\example\hotspot_bypass_vpn\ProxyServer.kt
============================================================

package com.example.hotspot_bypass_vpn

import android.util.Log
import java.io.InputStream
import java.io.OutputStream
import java.net.InetAddress
import java.net.ServerSocket
import java.net.Socket
import java.net.InetSocketAddress
import java.nio.ByteBuffer
import java.nio.channels.SocketChannel
import java.util.concurrent.*
import java.util.concurrent.atomic.AtomicInteger
import kotlin.concurrent.thread

class ProxyServer {
    private var serverSocket: ServerSocket? = null
    private var isRunning = false
    private val PORT = 8080

    // ULTRA-OPTIMIZED: Massive thread pool for Instagram's parallel connections
    private val clientPool = ThreadPoolExecutor(
        100,  // Core threads
        2000, // Max threads (Instagram can open 100+ connections)
        60L,
        TimeUnit.SECONDS,
        LinkedBlockingQueue(10000),
        ThreadFactory { r -> Thread(r).apply {
            priority = Thread.NORM_PRIORITY + 1
            name = "Proxy-${Thread.currentThread().id}"
        }},
        ThreadPoolExecutor.CallerRunsPolicy()
    )

    // Statistics
    private val activeConnections = AtomicInteger(0)
    private val totalConnections = AtomicInteger(0)
    private val bytesTransferred = AtomicInteger(0)

    fun start() {
        if (isRunning) {
            Log.w("ProxyServer", "Server already running")
            return
        }
        isRunning = true

        thread(name = "ProxyServer-Main", isDaemon = true) {
            try {
                serverSocket = ServerSocket()
                serverSocket?.reuseAddress = true
                serverSocket?.receiveBufferSize = 131072 // 128KB

                val bindAddress = InetSocketAddress("0.0.0.0", PORT)
                serverSocket?.bind(bindAddress, 200) // Bigger backlog

                Log.d("ProxyServer", "✓ ULTRA-FAST SERVER STARTED")
                Log.d("ProxyServer", "✓ Listening on 0.0.0.0:$PORT")
                Log.d("ProxyServer", "✓ Ready for Instagram traffic")

                // Stats thread
                thread(name = "Stats", isDaemon = true) {
                    while (isRunning) {
                        Thread.sleep(10000)
                        Log.d("ProxyServer", "Stats: Active=${activeConnections.get()}, Total=${totalConnections.get()}, Data=${bytesTransferred.get()/1024}KB")
                    }
                }

                while (isRunning && serverSocket?.isClosed == false) {
                    try {
                        val client = serverSocket?.accept()
                        if (client != null) {
                            totalConnections.incrementAndGet()

                            // ULTRA-OPTIMIZED: Configure socket for max performance
                            client.tcpNoDelay = true
                            client.keepAlive = true
                            client.soTimeout = 120000 // 2 min timeout
                            client.receiveBufferSize = 262144 // 256KB
                            client.sendBufferSize = 262144   // 256KB

                            Log.d("ProxyServer", "✓ Client ${totalConnections.get()}: ${client.inetAddress.hostAddress}")

                            clientPool.execute {
                                handleClient(client)
                            }
                        }
                    } catch (e: Exception) {
                        if (isRunning) {
                            Log.e("ProxyServer", "Accept error: ${e.message}")
                        }
                    }
                }
            } catch (e: Exception) {
                Log.e("ProxyServer", "✗ Server Error", e)
            }
        }
    }

    fun stop() {
        Log.d("ProxyServer", "Stopping server...")
        isRunning = false
        clientPool.shutdown()
        try {
            serverSocket?.close()
            Log.d("ProxyServer", "Server stopped")
        } catch (e: Exception) {
            Log.e("ProxyServer", "Error stopping: ${e.message}")
        }
    }

    private fun handleClient(client: Socket) {
        val clientId = "${client.inetAddress.hostAddress}:${client.port}"
        activeConnections.incrementAndGet()

        try {
            val input = client.getInputStream()
            val output = client.getOutputStream()

            // SOCKS5 Handshake - Fast path
            val version = input.read()
            if (version == -1) return
            if (version != 5) {
                Log.e("ProxyServer", "[$clientId] ✗ Bad version: $version")
                return
            }

            val nMethods = input.read()
            if (nMethods > 0) {
                input.skip(nMethods.toLong()) // Fast skip
            }

            // Send response immediately
            output.write(byteArrayOf(0x05, 0x00))
            output.flush()

            // SOCKS5 Request - Fast path
            if (input.read() != 5) return

            val cmd = input.read()
            if (cmd != 1) {
                Log.w("ProxyServer", "[$clientId] Unsupported cmd: $cmd")
                return
            }

            input.read() // skip reserved
            val atyp = input.read()

            var targetHost = ""
            when (atyp) {
                1 -> { // IPv4 - Fast path
                    val ipBytes = ByteArray(4)
                    input.read(ipBytes)
                    targetHost = InetAddress.getByAddress(ipBytes).hostAddress ?: ""
                }
                3 -> { // Domain - Common for Instagram CDN
                    val len = input.read()
                    val domainBytes = ByteArray(len)
                    input.read(domainBytes)
                    targetHost = String(domainBytes)
                }
                else -> {
                    Log.e("ProxyServer", "[$clientId] Bad atyp: $atyp")
                    return
                }
            }

            val portBytes = ByteArray(2)
            input.read(portBytes)
            val targetPort = ((portBytes[0].toInt() and 0xFF) shl 8) or (portBytes[1].toInt() and 0xFF)

            // Connect to target with timeout
            val targetSocket = Socket()
            try {
                // ULTRA-OPTIMIZED: Configure target socket
                targetSocket.tcpNoDelay = true
                targetSocket.keepAlive = true
                targetSocket.receiveBufferSize = 524288 // 512KB for Instagram media
                targetSocket.sendBufferSize = 524288
                targetSocket.soTimeout = 120000

                targetSocket.connect(InetSocketAddress(targetHost, targetPort), 15000)
                Log.d("ProxyServer", "[$clientId] ✓ → $targetHost:$targetPort")

                // Send success response
                val response = byteArrayOf(0x05, 0x00, 0x00, 0x01, 0, 0, 0, 0, 0, 0)
                output.write(response)
                output.flush()

                // ULTRA-OPTIMIZED: Zero-copy bidirectional relay
                val latch = CountDownLatch(2)

                // Client → Target
                val c2t = thread(name = "C2T-$clientId", isDaemon = true) {
                    try {
                        pipeOptimized(input, targetSocket.getOutputStream(), "C→T")
                    } finally {
                        try { targetSocket.shutdownOutput() } catch (e: Exception) {}
                        latch.countDown()
                    }
                }

                // Target → Client
                val t2c = thread(name = "T2C-$clientId", isDaemon = true) {
                    try {
                        pipeOptimized(targetSocket.getInputStream(), output, "T→C")
                    } finally {
                        try { client.shutdownOutput() } catch (e: Exception) {}
                        latch.countDown()
                    }
                }

                // Wait for both directions to complete
                latch.await(120, TimeUnit.SECONDS)

            } catch (e: Exception) {
                Log.e("ProxyServer", "[$clientId] Connect failed: ${e.message}")
                try {
                    val errorResponse = byteArrayOf(0x05, 0x01, 0x00, 0x01, 0, 0, 0, 0, 0, 0)
                    output.write(errorResponse)
                    output.flush()
                } catch (e2: Exception) {}
            } finally {
                try { targetSocket.close() } catch (e: Exception) {}
            }

        } catch (e: Exception) {
            Log.e("ProxyServer", "[$clientId] Error: ${e.message}")
        } finally {
            try { client.close() } catch (e: Exception) {}
            activeConnections.decrementAndGet()
        }
    }

    // ULTRA-OPTIMIZED: Large buffer with adaptive flushing
    private fun pipeOptimized(ins: InputStream, out: OutputStream, direction: String) {
        val buffer = ByteArray(65536) // 64KB buffer for max throughput
        var totalBytes = 0L

        try {
            var len: Int
            while (ins.read(buffer).also { len = it } != -1) {
                out.write(buffer, 0, len)
                totalBytes += len

                // Adaptive flushing:
                // - Small writes: flush immediately (interactive)
                // - Large writes: let TCP buffer (bulk transfer)
                if (len < 8192) {
                    out.flush()
                }

                // Periodic flush for bulk transfers
                if (totalBytes % 131072 == 0L) { // Every 128KB
                    out.flush()
                }
            }
        } catch (e: Exception) {
            // Connection closed - normal
        } finally {
            try {
                out.flush()
            } catch (e: Exception) {}
        }

        bytesTransferred.addAndGet(totalBytes.toInt())
    }
}

============================================================
FILE: app\src\main\java\com\example\hotspot_bypass_vpn\WiFiDirectBroadcastReceiver.kt
============================================================

package com.example.hotspot_bypass_vpn

import android.Manifest
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.net.NetworkInfo
import android.net.wifi.p2p.WifiP2pManager
import android.os.Build
import androidx.core.app.ActivityCompat

class WiFiDirectBroadcastReceiver(
    private val manager: WifiP2pManager,
    private val channel: WifiP2pManager.Channel,
    private val activity: MainActivity
) : BroadcastReceiver() {

    override fun onReceive(context: Context, intent: Intent) {
        when (intent.action) {
            WifiP2pManager.WIFI_P2P_STATE_CHANGED_ACTION -> {
                val state = intent.getIntExtra(WifiP2pManager.EXTRA_WIFI_STATE, -1)
                // Optional: Notify activity if Wifi P2P is disabled
                if (state != WifiP2pManager.WIFI_P2P_STATE_ENABLED) {
                    // Wi-Fi Direct is OFF
                }
            }
            WifiP2pManager.WIFI_P2P_PEERS_CHANGED_ACTION -> {
                // We don't need this for the Host, but if you scan for peers,
                // you would check permissions here too.
            }
            WifiP2pManager.WIFI_P2P_CONNECTION_CHANGED_ACTION -> {
                val networkInfo = intent.getParcelableExtra<NetworkInfo>(WifiP2pManager.EXTRA_NETWORK_INFO)

                if (networkInfo?.isConnected == true) {
                    // --- PERMISSION CHECK START ---
                    // We must check if we have permission before asking for IP/Password

                    // 1. Check for Fine Location (Required for all versions)
                    if (ActivityCompat.checkSelfPermission(context, Manifest.permission.ACCESS_FINE_LOCATION)
                        != PackageManager.PERMISSION_GRANTED) {
                        return // Exit if permission is missing
                    }

                    // 2. Check for Nearby Devices (Required for Android 13+)
                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
                        if (ActivityCompat.checkSelfPermission(context, Manifest.permission.NEARBY_WIFI_DEVICES)
                            != PackageManager.PERMISSION_GRANTED) {
                            return // Exit if permission is missing
                        }
                    }
                    // --- PERMISSION CHECK END ---

                    // If we passed the checks, it is safe to call these:
                    manager.requestConnectionInfo(channel, activity)

                    manager.requestGroupInfo(channel) { group ->
                        // Send the group info (Password/SSID) back to MainActivity
                        activity.updateGroupInfo(group)
                    }
                }
            }
            WifiP2pManager.WIFI_P2P_THIS_DEVICE_CHANGED_ACTION -> {
                // Respond to this device's wifi state changing
            }
        }
    }
}

============================================================
FILE: app\src\main\res\layout\activity_main.xml
============================================================

<?xml version="1.0" encoding="utf-8"?>
<androidx.constraintlayout.widget.ConstraintLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:padding="16dp"
    tools:context=".MainActivity">

    <ScrollView
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        app:layout_constraintTop_toTopOf="parent"
        app:layout_constraintBottom_toBottomOf="parent">

        <LinearLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:orientation="vertical"
            android:gravity="center_horizontal">

            <!-- APP TITLE -->
            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Hotspot Bypass VPN"
                android:textSize="24sp"
                android:textStyle="bold"
                android:layout_marginBottom="24dp"/>

            <!-- SECTION 1: HOST (SHARE INTERNET) -->
            <androidx.cardview.widget.CardView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                app:cardCornerRadius="8dp"
                app:cardElevation="4dp"
                android:layout_marginBottom="24dp">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:padding="16dp">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="MODE A: HOST (Share Internet)"
                        android:textStyle="bold"
                        android:textColor="@color/black"
                        android:layout_marginBottom="8dp"/>

                    <TextView
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="1. Turn on Mobile Data.\n2. Click Start to create a Wi-Fi Group."
                        android:textSize="12sp"
                        android:layout_marginBottom="12dp"/>

                    <Button
                        android:id="@+id/btn_start_host"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="Start Sharing"
                        android:backgroundTint="#2196F3"/>

                    <Button
                        android:id="@+id/btn_stop_host"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="Stop Sharing"
                        android:backgroundTint="#F44336"
                        android:layout_marginTop="4dp"/>

                    <!-- This text will update with SSID/Pass when you click Start -->
                    <TextView
                        android:id="@+id/tv_host_info"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="Status: Stopped"
                        android:background="#EEE"
                        android:padding="8dp"
                        android:layout_marginTop="8dp"
                        android:fontFamily="monospace"/>
                </LinearLayout>
            </androidx.cardview.widget.CardView>

            <!-- SECTION 2: CLIENT (CONNECT) -->
            <androidx.cardview.widget.CardView
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                app:cardCornerRadius="8dp"
                app:cardElevation="4dp">

                <LinearLayout
                    android:layout_width="match_parent"
                    android:layout_height="wrap_content"
                    android:orientation="vertical"
                    android:padding="16dp">

                    <TextView
                        android:layout_width="wrap_content"
                        android:layout_height="wrap_content"
                        android:text="MODE B: CLIENT (Connect)"
                        android:textStyle="bold"
                        android:textColor="@color/black"
                        android:layout_marginBottom="8dp"/>

                    <TextView
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="1. Connect to the Host's Wi-Fi manually.\n2. Enter IP Address from Host screen below.\n3. Click Connect to start VPN."
                        android:textSize="12sp"
                        android:layout_marginBottom="12dp"/>

                    <EditText
                        android:id="@+id/et_host_ip"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:hint="Host IP (e.g., 192.168.49.1)"
                        android:text="192.168.49.1"
                        android:inputType="text"
                        android:digits="0123456789." />

                    <EditText
                        android:id="@+id/et_host_port"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:hint="Port (e.g., 8080)"
                        android:inputType="number"
                        android:text="8080"/>

                    <Button
                        android:id="@+id/btn_connect"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="Connect &amp; Start VPN"
                        android:backgroundTint="#4CAF50"
                        android:layout_marginTop="8dp"/>

                    <Button
                        android:id="@+id/btn_stop_client"
                        android:layout_width="match_parent"
                        android:layout_height="wrap_content"
                        android:text="Stop VPN"
                        android:backgroundTint="#F44336"
                        android:layout_marginTop="4dp"/>
                </LinearLayout>
            </androidx.cardview.widget.CardView>

            <!-- DEBUG LOGS -->
            <TextView
                android:id="@+id/tv_status_log"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="Logs will appear here..."
                android:layout_marginTop="24dp"
                android:padding="8dp"
                android:textColor="#555"/>

            <Button
                android:id="@+id/btn_debug"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:text="Debug Test"
                android:backgroundTint="#FF9800" />

        </LinearLayout>
    </ScrollView>
</androidx.constraintlayout.widget.ConstraintLayout>
